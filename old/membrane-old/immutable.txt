/**
 * immutable.js
 *
 * A membrane that enforces that the underlying target not be changed. Any set operations,
 * both on this object and any inner objects, will throw an error. Also, any method calls that
 * change intrinsics, like Set.prototype.add, will also throw an error. This is achieved by
 * wrapping inner objects with an immutable membrane when they are retrieved.
 */

const Membrane = require('./membrane')
const { _checkState } = require('../../lib/util/misc')
const Proxy = require('../proxy')

// ------------------------------------------------------------------------------------------------
// Globals
// ------------------------------------------------------------------------------------------------

const IMMUTABLES = new WeakMap() // Target -> Immutable Proxy

const MUTABLE_SET_METHODS = ['add', 'clear', 'delete']
const MUTABLE_MAP_METHODS = ['clear', 'delete', 'set']
const MUTABLE_UINT8ARRAY_METHODS = ['copyWithin', 'fill', 'reverse', 'set', 'sort']

// Wrap all methods. Iterators returned are made immutable.
// Function arguments passed in ... when called .. are passed immutable
// Other methods that return anything ... must be immutable
// What about forEach methods? Callbacks?
/*
class Sidekick {}
Sidekick.set = new Set()
set.add({})
const C = run.deploy(Sidekick)
C.set.forEach(x => { x.n = 1 })
*/
// Handle these specific methods
// If any of the arguments passed in are functions, wrap so that when called
// their arguments are made immutable.
// How to know if an argument was already immutable?
// OR ... when the Set is retrieved, convert it to an immutable Set.
// Immutable iterator

// ------------------------------------------------------------------------------------------------
// Immutable
// ------------------------------------------------------------------------------------------------

class Immutable extends Membrane {
  defineProperty (target, prop, desc) {
    throw new Error('defineProperty disabled')
  }

  deleteProperty (target, prop) {
    throw new Error('deleteProperty disabled')
  }

  get (target, prop, receiver) {
    const value = super.get(target, prop, receiver)

    // Primitive types are returned directly
    if (typeof value !== 'object' && typeof value !== 'function') return value

    // Other Jigs, Code, and Berries are excluded from this object's immutability
    const Jig = require('../../lib/kernel/jig')
    const Code = require('../../lib/kernel/code')
    const Berry = require('../../lib/kernel/berry')
    if (value instanceof Jig || value instanceof Code || value instanceof Berry) return value

    // Check if we've already created a wrapped value
    if (IMMUTABLES.has(value)) return IMMUTABLES.get(value)

    // Object types are wrapped to be immutable
    const immutable = new Proxy(value, new Immutable())
    IMMUTABLES.set(value, immutable)
    return immutable

    Proxy._getProxy(value)
  }

  getOwnPropertyDescriptor (target, prop) {
    const desc = super.getOwnPropertyDescriptor(target, prop)
    if (!desc) return undefined

    const value = desc.value

    // This immutable membrane does not support getters and setters yet
    _checkState('value' in desc, 'Getters and setters not supported')

    // Primitive types are returned directly
    if (typeof value !== 'object' && typeof value !== 'function') return desc

    // Other Jigs, Code, and Berries are excluded from this object's immutability
    const Jig = require('../../lib/kernel/jig')
    const Code = require('../../lib/kernel/code')
    const Berry = require('../../lib/kernel/berry')
    if (value instanceof Jig || value instanceof Code || value instanceof Berry) return desc

    // Check if we've already created a wrapped value
    if (IMMUTABLES.has(desc.value)) {
      desc.value = IMMUTABLES.get(value)
      return desc
    }

    // Object types are wrapped to be immutable
    const immutable = new Proxy(value, new Immutable())
    IMMUTABLES.set(value, immutable)
    desc.value = immutable
    return desc
  }
}

// ------------------------------------------------------------------------------------------------
// ImmutableMethod
// ------------------------------------------------------------------------------------------------

// We apply these to intrinsics
class ImmutableMethod {

}

// ------------------------------------------------------------------------------------------------

module.exports = Immutable
