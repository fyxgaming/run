/**
 * utxo-corrector
 *
 * Makes corrections to UTXOs returned from a remote server for safe use in RUN.
 *
 * In case the server has a bug, RUN must be able to handle duplicate utxos returned. If we
 * don't dedup, then later we may create a transaction with more than one of the same input.
 *
 * Also, most APIs have delays in indexing UTXOs after a broadcast. Because we create the
 * transaction locally, we can add and remove UTXOs we know about that.
 */

// ------------------------------------------------------------------------------------------------
// UtxoCorrector
// ------------------------------------------------------------------------------------------------

class UtxoCorrector {
  // --------------------------------------------------------------------------
  // constructor
  // --------------------------------------------------------------------------

  constructor () {
    this._broadcasts = [] // [{ txid, rawtx, time }]
    this._indexingDelay = 30 * 1000
  }

  // --------------------------------------------------------------------------
  // notifyBroadcast
  // --------------------------------------------------------------------------

  notifyBroadcast (txid, rawtx) {
    this._expireBroadcasts()
    this._broadcasts.push({ txid, rawtx, time })
  }

  // --------------------------------------------------------------------------
  // correctUtxos
  // --------------------------------------------------------------------------

  correctUtxos (utxos, script) {
    this._expireBroadcasts()
    utxos = this._dedupUtxos(utxos)
    utxos = this._correctForRecentBroadcasts(utxos, script)
    return utxos
  }

  // --------------------------------------------------------------------------
  // _expireBroadcasts
  // --------------------------------------------------------------------------

  _expireBroadcasts () {
    const now = Date.now()
    const unexpired = x => now - x.time < this._indexingDelay
    this._broadcasts = this._broadcasts.filter(unexpired)
  }

  // --------------------------------------------------------------------------
  // _dedupUtxos
  // --------------------------------------------------------------------------

  _dedupUtxos (utxos) {
    const locations = new Set()

    return utxos.filter(utxo => {
      const location = `${utxo.txid}_o${utxo.vout}`

      if (locations.has(location)) {
        if (Log._warnOn) Log._warn(TAG, 'Duplicate utxo returned from server:', location)
        return false
      }

      locations.add(location)
      return true
    })
  }

  // --------------------------------------------------------------------------
  // _correctForRecentBroadcasts
  // --------------------------------------------------------------------------

  async _correctForRecentBroadcasts (utxos, script) {
    this._broadcasts.forEach(data => {
      data.bsvtx = data.bsvtx || new bsv.Transaction(data.rawtx)
    })

    // Add all utxos from our broadcast cache for this script that aren't already there
    this._broadcasts.forEach(data => {
      data.bsvtx.outputs.forEach((output, vout) => {
        if (output.script.equals(script) && !utxos.some(utxo => utxo.txid === txid && utxo.vout === vout)) {
          utxos.push({ txid, vout, script: output.script.toHex(), satoshis: output.satoshis })
        }
      })
    })

    // Remove all utxos that we know are spent because they are in our broadcast cache
    this._broadcasts.forEach(data => {
      const inputSpendsUtxo = (input, utxo) =>
        input.prevTxId.toString('hex') === utxo.txid &&
        input.outputIndex === utxo.vout

      utxos = utxos.filter(utxo => !data.bsvtx.inputs.some(input => inputSpendsUtxo(input, utxo)))
    })

    return utxos
  }
}

module.exports = UtxoCorrector
