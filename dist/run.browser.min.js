/*! For license information please see run.browser.min.js.LICENSE */
var Run=function(t){var e={};function n(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)n.d(r,o,function(e){return t[e]}.bind(null,o));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=3)}([function(t,e,n){"use strict";var r=n(10),o=n(28),s=Object.prototype.toString;function i(t){return"[object Array]"===s.call(t)}function a(t){return null!==t&&"object"==typeof t}function c(t){return"[object Function]"===s.call(t)}function l(t,e){if(null!=t)if("object"!=typeof t&&(t=[t]),i(t))for(var n=0,r=t.length;n<r;n++)e.call(null,t[n],n,t);else for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&e.call(null,t[o],o,t)}t.exports={isArray:i,isArrayBuffer:function(t){return"[object ArrayBuffer]"===s.call(t)},isBuffer:o,isFormData:function(t){return"undefined"!=typeof FormData&&t instanceof FormData},isArrayBufferView:function(t){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(t):t&&t.buffer&&t.buffer instanceof ArrayBuffer},isString:function(t){return"string"==typeof t},isNumber:function(t){return"number"==typeof t},isObject:a,isUndefined:function(t){return void 0===t},isDate:function(t){return"[object Date]"===s.call(t)},isFile:function(t){return"[object File]"===s.call(t)},isBlob:function(t){return"[object Blob]"===s.call(t)},isFunction:c,isStream:function(t){return a(t)&&c(t.pipe)},isURLSearchParams:function(t){return"undefined"!=typeof URLSearchParams&&t instanceof URLSearchParams},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:l,merge:function t(){var e={};function n(n,r){"object"==typeof e[r]&&"object"==typeof n?e[r]=t(e[r],n):e[r]=n}for(var r=0,o=arguments.length;r<o;r++)l(arguments[r],n);return e},deepMerge:function t(){var e={};function n(n,r){"object"==typeof e[r]&&"object"==typeof n?e[r]=t(e[r],n):e[r]="object"==typeof n?t({},n):n}for(var r=0,o=arguments.length;r<o;r++)l(arguments[r],n);return e},extend:function(t,e,n){return l(e,(function(e,o){t[o]=n&&"function"==typeof e?r(e,n):e})),t},trim:function(t){return t.replace(/^\s*/,"").replace(/\s*$/,"")}}},function(t,e){t.exports=bsv},function(t,e,n){(function(e){const r=n(1);function o(t){if(!(t.outputs.length&&t.outputs[0].script.isSafeDataOut()&&7===t.outputs[0].script.chunks.length&&"run"===t.outputs[0].script.chunks[2].buf.toString("utf8")))throw new Error(`not a run tx: ${t.hash}`);if(!(1===t.outputs[0].script.chunks[3].buf.length&&1===t.outputs[0].script.chunks[3].buf[0])){const e="Hint: Are you trying to load jigs created by a different version of run? This is not possible in the private alpha, sorry.";throw new Error(`Unsupported run protocol in tx: ${t.hash}\n\n${e}`)}}function s(t){return"function"==typeof t&&(/^class [A-Za-z0-9_]/.test(t.toString())||/^function [A-Za-z0-9_]/.test(t.toString()))&&-1===t.toString().indexOf("[native code]")}const i=" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890-=~!@#$%^&*()_+,./;'[]\\<>?:\"{}|".split(""),a="t08sY]m'#$Dy1`}pCKrHG)f9[uq%3\\ha=!ZVMkJ-*L\"xz67R? W~@wdO:Ecg|ITe52.+{ovBj>(&,/Q4lA;^<NPnXSFi_Ub".split("");function c(t){const e=t.split("").map(t=>-1!==a.indexOf(t)?i[a.indexOf(t)]:t).join("");try{return JSON.parse(e)}catch(t){throw new Error(`unable to parse decrypted run data\n\n${t.toString()}\n\n${e}`)}}function l(){const t=n(3);if(!t.instance)throw new Error("Run not instantiated");return t.instance}t.exports={aaed:1,aac:function(t){if("string"!=typeof t)throw new Error("owner must be a pubkey string");try{new r.PublicKey(t)}catch(t){throw new Error(`owner is not a valid public key\n\n${t}`)}},aad:function(t){if("number"!=typeof t)throw new Error("satoshis must be a number");if(!Number.isInteger(t))throw new Error("satoshis must be an integer");if(isNaN(t)||!isFinite(t))throw new Error("satoshis must be finite");if(t<0)throw new Error("satoshis must be non-negative");if(t>1e8)throw new Error(`satoshis must be less than ${1e8}`)},aae:o,aaf:function(t){return o(t),c(t.outputs[0].script.chunks[5].buf.toString("utf8"))},aag:function(t,e){try{o(t)}catch(t){return"other"}if(0===e)return"rundata";const n=t.outputs[0].script.chunks[5].buf.toString("utf8");try{const t=c(n);if(e>=1&&e<1+t.code.length)return"code";if(e>=1+t.code.length&&e<1+t.code.length+t.jigs)return"jig"}catch(t){}return"other"},aah:function(t){const e=t.toString(),n=Object.getPrototypeOf(t);if(n.prototype){const r=/^class \S+ extends \S+ {/;return e.replace(r,`class ${t.name} extends ${n.name} {`)}return e},aai:s,aaj:function(t){return JSON.stringify(t).split("").map(t=>-1!==i.indexOf(t)?a[i.indexOf(t)]:t).join("")},aak:c,aal:function t(n,r=[],o=null,s=null,i=[null]){switch(typeof n){case"undefined":return{$class:"undefined"};case"string":case"boolean":return n;case"number":if(isNaN(n)||!isFinite(n))throw new Error(`${n} cannot be serialized to json`);return n;case"symbol":throw new Error(`${n.toString()} cannot be serialized to json`)}if(null===n)return null;for(const t of r){const e=t(n,o,s);if(void 0!==e)return e}if("function"==typeof n)throw new Error(`${n} cannot be serialized to json`);if(-1!==i.indexOf(n))throw new Error(`circular reference detected: ${s}`);const a=Object.getPrototypeOf(Object.getPrototypeOf(n)),c=null===a,u=Array.isArray(n)&&null===Object.getPrototypeOf(a);if(c||u){const e=c?{}:[];return i.push(n),Object.keys(n).forEach(o=>{if(o.startsWith("$"))throw new Error("$ properties must not be defined");e[o]=t(n[o],r,e,o,i)}),i.pop(),e}const h=l().code.aayb.Uint8Array;if(n.constructor===h||n.constructor===Uint8Array)return{$class:"Uint8Array",base64Data:e.from(n).toString("base64")};const p=n.constructor.name?n.constructor.name:n.toString();throw new Error(`${p} cannot be serialized to json`)},aam:function t(n,r=[],o=null,s=null,i=[null]){switch(typeof n){case"undefined":throw new Error("JSON should not contain undefined");case"string":case"boolean":return n;case"number":if(isNaN(n)||!isFinite(n))throw new Error(`JSON should not contain ${n}`);return n;case"function":throw new Error(`JSON should not contain ${n}`);case"symbol":throw new Error(`JSON should not contain ${n.toString()}`)}if(null===n)return null;if(-1!==i.indexOf(n))throw new Error(`circular reference detected: ${s}`);for(const t of r){const e=t(n,o,s);if(void 0!==e)return e}if("Uint8Array"===n.$class){return new(0,l().code.aayb.Uint8Array)(e.from(n.base64Data,"base64"))}if("undefined"===n.$class)return;const a=Object.getPrototypeOf(Object.getPrototypeOf(n)),c=null===a,u=Array.isArray(n)&&null===Object.getPrototypeOf(a);if(c||u){const e=c?{}:[];return i.push(n),Object.keys(n).forEach(o=>{if(o.startsWith("$"))throw new Error("$ properties must not be defined");e[o]=t(n[o],r,e,o,i)}),i.pop(),e}const h=n.constructor.name?n.constructor.name:n.toString();throw new Error(`JSON should not contain ${h}`)},aan:function(t){const{Jig:Jig}=n(3);return(e,n,r)=>{if(e instanceof Jig||s(e))return t.push(e),{$index:t.length-1}}},aao:function(t){return e=>{if(void 0!==e.$index)return t[e.$index]}},aap:function t(e,n=[],r=null,o=null,s=new Set){Array.isArray(n)?n.forEach(t=>t(e,r,o)):n(e,r,o),"object"==typeof e&&e&&!s.has(e)&&(s.add(e),Object.keys(e).forEach(r=>{t(e[r],n,e,r,s)}))},aaq:l,aar:function(t,e){return t===e||t.origin&&"_"!==t.origin[0]&&t.origin===e.origin},aas:function(t){switch(t){case"main":return"Mainnet";case"test":return"Testnet";case"stn":return"Stn";case"mock":return"Mocknet";default:throw new Error(`Unknown network: ${t}`)}},bsvNetwork:function(t){return"main"===t?"mainnet":"testnet"},aafd:class{constructor(){this.tasks=[]}async enqueue(t){return new Promise((e,n)=>{this.tasks.push({func:t,reject:n,resolve:e}),1===this.tasks.length&&this.execNext()})}async execNext(){const t=this.tasks[0];try{const e=t.func();t.resolve(e instanceof Promise?await e:e)}catch(e){t.reject(e)}finally{this.tasks.shift(),this.tasks.length&&this.execNext()}}}}}).call(this,n(7).Buffer)},function(t,e,n){(function(e){const r=n(1),o=n(6),s=n(24),{Transaction:i}=n(8),util=n(2),{Pay:a,Purse:c}=n(25),l=n(44),{Blockchain:u,BlockchainServer:h}=n(9),p=n(45),{StateCache:f}=n(46),{PrivateKey:d}=r,Jig=n(5),Token=n(47),expect=n(18);class g{constructor(t={}){this.logger=function(t){switch(typeof t){case"object":t=t||{};break;case"undefined":t={warn:console.warn,error:console.error};break;default:throw new Error(`Option 'logger' must be an object. Received: ${t}`)}return t=Object.assign({},t),["info","debug","warn","error"].forEach(e=>{t[e]=t[e]||(()=>{})}),t}(t.logger),this.blockchain=function(t,e,n){switch(typeof t){case"object":if(!u.aahc(t))throw new Error("Invalid 'blockchain'");return t;case"string":case"undefined":{const r=g.instance?g.instance.blockchain:null;return"mock"===e?new p({lastBlockchain:r}):new h({network:e,api:t,logger:n,lastBlockchain:r})}default:throw new Error(`Option 'blockchain' must be an object or string. Received: ${t}`)}}(t.blockchain,t.network,this.logger),function(t){r.Networks.defaultNetwork=util.bsvNetwork(t);const e=r.Transaction.prototype.sign;r.Transaction.prototype.sign=function(...t){const n=r.Transaction.Input.prototype.isValidSignature;r.Transaction.Input.prototype.isValidSignature=()=>!0;const o=e.call(this,...t);return r.Transaction.Input.prototype.isValidSignature=n,o}}(this.blockchain.network),this.app=function(t){switch(typeof t){case"string":return t;case"undefined":return"";default:throw new Error(`Option 'app' must be a string. Received: ${t}`)}}(t.app),this.state=function(t){switch(typeof t){case"object":if(!t)throw new Error("Option 'state' must not be null");if("function"!=typeof t.get)throw new Error("State requires a get method");if("function"!=typeof t.set)throw new Error("State requires a set method");return t;case"undefined":return g.instance&&g.instance.state?g.instance.state:new f;default:throw new Error(`Option 'state' must be an object. Received: ${t}`)}}(t.state),this.owner=function(t,e,n,r){switch(typeof t){case"string":case"object":case"undefined":return new l(t,{network:e,logger:n,run:r});default:throw new Error(`Option 'owner' must be a valid key or address. Received: ${t}`)}}(t.owner,this.blockchain.network,this.logger,this),this._purse=y(t.purse,this.blockchain,this.logger),this.code=function(t,e,n){switch(typeof t){case"object":if(t&&t instanceof o)return t;break;case"undefined":if(g.instance){if(g.instance.code.sandbox.toString()===e.toString())return g.instance.code;g.instance.code.deactivate()}return new o({sandbox:e,logger:n})}throw new Error("Option 'code' must be an instance of Code")}(t.code,function(t){switch(typeof t){case"boolean":return t;case"object":if(t&&t instanceof RegExp)return t;throw new Error(`Invalid option 'sandbox'. Received: ${t}`);case"undefined":return!0;default:throw new Error(`Option 'sandbox' must be a boolean or RegExp. Received: ${t}`)}}(t.sandbox),this.logger),this.aasc=new s(this),this.transaction=new i(this),this.loadQueue=new util.aafd,this.activate(),this.blockchain instanceof p&&this.blockchain.fund(this.purse.address,1e8)}get purse(){return this._purse}set purse(t){this._purse=y(t,this.blockchain,this.logger)}async load(t){return this.aab(),this.loadQueue.enqueue(()=>this.transaction.load(t))}async deploy(t){return this.aab(),this.code.deploy(t),await this.sync(),t.location}async sync(){return this.owner.sync()}activate(){return g.instance&&g.instance.deactivate(),g.instance=this,r.Networks.defaultNetwork=util.bsvNetwork(this.blockchain.network),this.code.activate(this.blockchain.network),this}deactivate(){g.instance&&(g.instance.code.deactivate(),g.instance=null)}aab(){if(g.instance!==this){throw new Error(`This Run instance is not active\n\n${"Hint: Call run.activate() on this instance first"}`)}}}function y(t,e,n){switch(typeof t){case"string":return new c({privkey:t,blockchain:e,logger:n});case"undefined":return new c({blockchain:e,logger:n});case"object":if(!t||t instanceof d)return new c({privkey:t,blockchain:e,logger:n});if("function"!=typeof t.pay)throw new Error("Purse requires a pay method");return t;default:throw new Error(`Option 'purse' must be a valid private key or Pay API. Received: ${t}`)}}g.version="0.4.1",g.protocol=util.aaed,g.aaxb=util,g.instance=null,g.Blockchain=u,g.BlockchainServer=h,g.Code=o,g.Mockchain=p,g.Pay=a,g.Purse=c,g.StateCache=f,g.Jig=Jig,g.Token=Token,g.expect=expect,e.Jig=Jig,e.Token=Token,t.exports=g}).call(this,n(4))},function(t,e){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(t){"object"==typeof window&&(n=window)}t.exports=n},function(t,e,n){const util=n(2);t.exports=class Jig{constructor(...t){const e=util.aaq();if(!e.code.aaeb(this.constructor)){e.transaction.begin();try{return new(e.code.deploy(this.constructor))(...t)}finally{e.transaction.end()}}const n=[];let r=this.constructor;for(;r!==Jig;)n.push(r),r=Object.getPrototypeOf(r);if(0===n.length)throw new Error("Jig must be extended");const o=/\s+constructor\s*\(/;if(n.some(t=>o.test(t.toString())))throw new Error("Jig must use init() instead of constructor()");const s=["origin","location","owner","satoshis","sync"];n.forEach(t=>{s.forEach(t=>{if(Object.prototype.hasOwnProperty.call(n[0].prototype,t))throw new Error(`must not override ${t}`)})});const i=[];[...n,Jig].forEach(t=>{Object.getOwnPropertyNames(t.prototype).forEach(t=>i.push(t))});const a=[...i,"owner","satoshis","origin","location"];function c(){aacd.aabc=[],aacd.aadc=new Set,aacd.aacc=new Set,aacd.aaec=new Map,aacd.aafc=new Map,aacd.aazb=new Map,aacd.aaac=!0,aacd.error=null}const l=()=>{if(aacd.aaac&&this.origin&&"!"===this.origin[0])throw new Error(`${this.origin.slice(1)}`)},u=this,h={parent:null,name:null},p=new Proxy(this,h),f=()=>aacd.aabc[aacd.aabc.length-1],d=()=>aacd.aabc.length&&f()===u,g=()=>aacd.aabc.length&&f().constructor!==p.constructor;let y=!!aacd.stateToInject;return h.getPrototypeOf=function(t){return l(),aacd.aabc.length&&aacd.aazb.set(u,p),Object.getPrototypeOf(t)},h.setPrototypeOf=function(t,e){throw new Error("setPrototypeOf disallowed")},h.isExtensible=function(t){return!0},h.preventExtensions=function(t){throw new Error("preventExtensions disallowed")},h.getOwnPropertyDescriptor=function(t,e){if(l(),aacd.aabc.length&&aacd.aazb.set(u,p),!this.has(t,e))return;const n=Object.getOwnPropertyDescriptor(t,e);return n?Object.assign({},n,{value:this.get(t,e)}):void 0},h.defineProperty=function(t,e,n){throw new Error("defineProperty disallowed")},h.has=function(t,e){if(l(),aacd.aabc.length&&aacd.aazb.set(u,p),aacd.aaac&&"_"===e[0]&&g())throw new Error(`cannot check ${e} because it is private`);return aacd.aabc.length&&(!(t instanceof Jig)||!a.includes(e))&&aacd.aacc.add(u),e in t},h.get=function(t,e,n){if(l(),aacd.aabc.length&&aacd.aazb.set(u,p),"$object"===e)return p;const r=t instanceof Jig;if(aacd.aaac&&r&&["origin","location"].includes(e)&&"_"===t[e][0])throw new Error(`sync required before reading ${e}`);if(r&&["origin","constructor"].includes(e))return t[e];const o=r&&"function"==typeof t[e];if(aacd.aabc.length&&!o&&aacd.aacc.add(u),"_"===e[0]&&g())throw new Error(`cannot get ${e} because it is private`);return["undefined","boolean","number","string","symbol"].includes(typeof t[e])?t[e]:e===Symbol.iterator?t[e].bind(t):"object"==typeof t[e]?null===t[e]?null:t[e]instanceof Jig?t[e]:aacd.aaac?new Proxy(t[e],Object.assign({},this,{parent:t,name:e})):t[e]:"constructor"===e?t[e]:"function"==typeof t[e]?!util.aai(t[e])||r&&i.includes(e)?new Proxy(t[e],Object.assign({},this,{parent:t,name:e})):t[e]:void 0},h.set=function(t,e,n,r){if(l(),aacd.aabc.length&&aacd.aazb.set(u,p),aacd.aaac){if(!d())throw new Error(`must not set ${e} outside of a method`);if(t instanceof Jig){if(["origin","location",...i].includes(e))throw new Error(`must not set ${e}`)}else{if("function"==typeof t[e])throw new Error(`must not overwrite internal method ${e}`);if("function"==typeof t)throw new Error(`must not set ${e} on method ${t.name}`)}}return t[e]=n,!0},h.deleteProperty=function(t,e){if(l(),aacd.aabc.length&&aacd.aazb.set(u,p),aacd.aaac){if(!d())throw new Error(`must not delete ${e} outside of a method`);if(t instanceof Jig){if(["origin","location",...i].includes(e))throw new Error(`must not delete ${e}`)}else if("function"==typeof t[e])throw new Error(`must not delete internal method ${e}`)}return delete t[e],!0},h.ownKeys=function(t){return l(),aacd.aabc.length&&aacd.aazb.set(u,p),aacd.aabc.length&&aacd.aacc.add(u),g()?Reflect.ownKeys(t).filter(t=>"_"!==t[0]):Reflect.ownKeys(t)},h.apply=function(t,e,n){const r=this.parent instanceof Jig;if(r&&"_"===this.name[0]&&(!aacd.aabc.length||f().constructor!==p.constructor))throw new Error(`cannot call ${this.name} because it is private`);if(r&&"sync"===this.name){if(aacd.aabc.length)throw new Error("sync may only be called externally");return t.call(p,...n)}const o=util.aaq();o.transaction.begin();let s=null;r||d()||(s=Object.assign({},aacd),c());const i=aacd.aafc.get(u)||new Set;aacd.aabc.forEach(t=>i.add(t)),aacd.aafc.set(u,i),aacd.aabc.push(u),aacd.aazb.set(u,p);try{if(r&&"init"===this.name){if(y)throw new Error("init cannot be called twice");y=!0,aacd.aadc.add(u)}const e=new Set(aacd.aacc);aacd.aaac=!1;const i=[],a=t=>{util.aai(t)&&o.code.deploy(t)},l=[a,util.aan(i)],h=r?util.aal(n,l):null;if(!aacd.aaec.has(u)){const t={refs:[]},e=[a,util.aan(t.refs)];t.json=util.aal(Object.assign({},u),e),aacd.aaec.set(u,t)}aacd.aaac=!0,aacd.aacc=e;const f=r?util.aam(h,[util.aao(i)]):n,d=t.call(r?p:this.parent,...f);if(r&&"init"===this.name&&void 0!==d)throw new Error("init must not return");if(r&&(util.aac(u.owner),util.aad(u.satoshis)),aacd.error)throw new Error(`internal errors must not be swallowed\n\n${aacd.error}`);if(aacd.aabc.pop(),!aacd.aabc.length){const t=new Set(aacd.aacc);aacd.aaac=!1;const e=(t,e,n)=>{if(void 0!==t.$object&&t.$object!==p){throw new Error(`property ${n} is owned by a different jig\n\n${`Hint: Consider saving a clone of ${n}'s value instead.`}`)}},i=new Map,a=new Set(aacd.aacc);Array.from(aacd.aaec.keys()).forEach(t=>a.add(t)),a.forEach(t=>{const n=[],r=[util.aan(n),e],o=util.aal(Object.assign({},t),r);i.set(t,{json:o,refs:n})});const l=[];for(const[t,e]of aacd.aaec){const n=i.get(t),r=(t,e)=>t!==n.refs[e];(JSON.stringify(e.json)!==JSON.stringify(n.json)||e.refs.some(r))&&l.push(t)}if(aacd.aaac=!0,aacd.aacc=t,aacd.aadc.size||l.length){if(!r)throw new Error(`internal method ${this.name} may not be called to change state`);const t=new Set,e=new Set,s=new Set(aacd.aacc),a=n=>{e.add(n),aacd.aadc.has(n)||t.add(n)};l.forEach(t=>{aacd.aafc.get(t).forEach(t=>a(t)),a(t)}),aacd.aadc.forEach(t=>{aacd.aafc.get(t).forEach(t=>a(t)),a(t)}),o.transaction.aanb(u,this.name,n,t,e,s,aacd.aaec,i,aacd.aazb)}s?(aacd.aadc.forEach(t=>s.aadc.add(t)),aacd.aacc.forEach(t=>s.aacc.add(t)),aacd.aaec.forEach((t,e)=>{aacd.aaec.has(e)||s.aaec.set(e,t)}),aacd.aazb.forEach((t,e)=>{aacd.aazb.has(e)||s.aazb.set(e,t)}),aacd.aafc.forEach((t,e)=>{aacd.aafc.has(e)?t.forEach(t=>s.get(e).add(t)):s.aafc.set(e,t)}),Object.assign(aacd,s)):c()}return o.transaction.end(),d}catch(t){aacd.error||(aacd.error=t),s&&Object.assign(aacd,s),aacd.aabc.pop(),aacd.aabc.length||(aacd.aaec.forEach((t,e)=>{Object.keys(e).forEach(t=>delete e[t]),Object.assign(e,util.aam(t.json,[util.aao(t.refs)]))}),c()),o.transaction.end();const e=t.toString();if("TypeError: Date is not a constructor"===e){throw new Error(`${e}\n\n${"Hint: Date is disabled inside jigs because it is non-deterministic."}\n${"Consider passing in the Date as a number instead."}`)}throw t}},aacd.stateToInject?(Object.assign(this,aacd.stateToInject),p):(this.owner=aacd.aabc.length?aacd.aabc[aacd.aabc.length-1].owner:e.transaction.owner,this.satoshis=0,this.origin="_",this.location="_",p.init(...t),p)}init(){}toString(){return`[jig ${this.constructor.name}]`}sync(t){return util.aaq().aasc.sync(Object.assign({},t,{target:this}))}static[Symbol.hasInstance](t){const e=util.aaq();if("object"!=typeof t||!("location"in t))return!1;let n=e.code.aafb(this);if(!n){const t=util.aas(e.blockchain.network);if(n=e.code.aafb(this[`origin${t}`]),!n)return!1}let r=Object.getPrototypeOf(t);for(;r;){if(r===n.prototype)return!0;r=Object.getPrototypeOf(r)}return!1}}},function(module,exports,__webpack_require__){(function(global){const Jig=__webpack_require__(5),util=__webpack_require__(2),bsv=__webpack_require__(1),ses=__webpack_require__(22),aagd=["origin","location","originMainnet","locationMainnet","originTestnet","locationTestnet","originStn","locationStn","originMocknet","locationMocknet","owner","ownerMainnet","ownerTestnet","ownerStn","ownerMocknet"];class Code{constructor(t={}){this.aarc=new Map,this.sandbox=void 0===t.sandbox||t.sandbox,this.logger=void 0!==t.logger?t.logger:null,"undefined"==typeof window||window.document.body||(window.document.body=document.createElement("body")),this.sandboxEvaluator=new SESEvaluator,this.globalEvaluator=new GlobalEvaluator({logger:this.logger}),this.aayb=this.sandboxEvaluator.aayb,this.aahb()}aaeb(t){const e=this.aarc.get(t);return e&&t===e}aafb(t){return this.aaeb(t)?t:this.aarc.get(t)}static aahd(t){const e={},n=["deps",...aagd],r=Object.keys(t).filter(t=>!n.includes(t)),o=[];return r.forEach(n=>{util.aal(t[n],[util.aan(o)],null,`${t.name}.${n}`),e[n]=t[n]}),{props:e,refs:o}}deploy(t){if(t===this.Jig||t===Jig)return this.Jig;if(!util.aai(t))throw new Error(`${t} is not deployable`);const e=this.aarc.get(t),n=util.aaq(),r=util.aas(n.blockchain.network);if(e&&Object.keys(e).includes(`origin${r}`)&&Object.keys(e).includes(`location${r}`))return e;const o=Object.keys(t);if(o.includes(`location${r}`)){const e=this.aarc.get(t[`location${r}`]);if(e)return e}if(o.includes("deps")&&(s=t.deps,null!==Object.getPrototypeOf(Object.getPrototypeOf(s))))throw new Error("deps must be an object");var s;aagd.forEach(e=>{if((e=>o.includes(e)&&"string"!=typeof t[e])(e))throw new Error(`${e} must be a string: ${t[e]}`)}),n.transaction.begin();try{const e={},s=Object.getPrototypeOf(t),i=o.includes("deps")?Object.assign({},t.deps):{};if(s!==Object.getPrototypeOf(Object)){if(e[s.name]=this.deploy(s),i[s.name]){if(this.aafb(i[s.name])!==e[s.name])throw new Error(`unexpected parent dependency ${s.name}`)}s.name in i||s===this.aarc.get(Jig)||s===Jig||(i[s.name]=s)}const a=this.aarc.get(t);if(a&&Object.keys(a).includes(`origin${r}`)&&Object.keys(a).includes(`location${r}`))return a;const[c,l]=this.evaluate(t,util.aah(t),t.name,e,this.sandbox);this.aarc.set(t,c),this.aarc.set(c,c);const{props:u,refs:h}=Code.aahd(t);Object.keys(u).forEach(t=>{c[t]=u[t]});const p=h.filter(t=>util.aai(t));if(o.includes(`origin${r}`)||o.includes(`location${r}`))o.includes(`origin${r}`)&&(c[`origin${r}`]=c.origin=t.origin=t[`origin${r}`]),c[`location${r}`]=c.location=t.location=t[`location${r}`]||t.origin,c[`owner${r}`]=c.owner=t.owner=t[`owner${r}`],this.aarc.set(c[`location${r}`],c);else{const e=n.blockchain.network,o=o=>{n.blockchain.network===e&&(t.origin=t.location=c.origin=c.location=o,t.owner=c.owner=t[`owner${r}`]),c[`origin${r}`]=c[`location${r}`]=o,t[`origin${r}`]=t[`location${r}`]=o,this.aarc.set(o,c)},s=()=>{n.blockchain.network===e&&(delete t.origin,delete t.location,delete c.origin,delete c.location,delete t.owner,delete c.owner),delete t[`origin${r}`],delete t[`location${r}`],delete c[`origin${r}`],delete c[`location${r}`],delete t[`owner${r}`],delete c[`owner${r}`]},a=n.transaction.aamb(t,c,i,u,o,s);t[`origin${r}`]=t[`location${r}`]=a,c[`origin${r}`]=c[`location${r}`]=a,t[`owner${r}`]=c[`owner${r}`]=t.owner}return l&&Object.entries(i).forEach(([t,n])=>{n!==s&&n!==e[s.name]&&(l[t]=this.deploy(n))}),p.forEach(t=>this.deploy(t)),Object.keys(u).forEach(t=>{this.aacd.aaac=!1,util.aap(c[t],(e,n,r)=>{const o=this.aafb(e);o&&r&&(n[r]=o),o&&!r&&(c[t]=o)}),this.aacd.aaac=!0}),Object.keys(i).length&&(c.deps={},Object.keys(i).forEach(t=>{c.deps[t]=this.deploy(i[t])})),c}finally{n.transaction.end()}}async aagb(t,e,n,r,o,s=new Map){if(this.aarc.has(e))return this.aarc.get(e);if(s.has(e))return s.get(e);const i=e.slice(0,64),a=parseInt(e.slice(66));if(n.outputs[a].script.toAddress(o).toString()!==new bsv.PublicKey(t.owner,o).toAddress().toString())throw new Error(`bad def owner: ${e}`);const c={};let l=null,u=null;const h=new Promise((t,e)=>{l=t,u=e});s.set(e,h);try{const o=/^class \w* extends (\w*)[\s]*{/;let a=null;if(o.test(t.text)){a=t.text.match(o)[1];let e=(t.deps||{})[a];"Jig"===a&&void 0===e?c.Jig=this.Jig:(e.startsWith("_")&&(e=n.hash+e),c[a]=await r.transaction.load(e,{partiallyInstalledCode:s}))}const u=t.text.match(/^(class|function) (\w+)[( ]/)[2],[h,p]=this.evaluate(null,t.text,u,c,this.sandbox);h.origin=h.location=e,h.owner=t.owner;const f=util.aas(r.blockchain.network);if(h[`origin${f}`]=h[`location${f}`]=e,h[`owner${f}`]=t.owner,l(h),p){const e=Object.entries(t.deps||{}).map(([t,e])=>{if(t===a)return;const o=e.startsWith("_")?n.hash+e:e;return r.transaction.load(o,{partiallyInstalledCode:s}).then(e=>{p[t]=e})});await Promise.all(e)}t.deps&&(h.deps={},Object.keys(t.deps).forEach(t=>{h.deps[t]=p[t]||c[t]}));const d=[],g=(t,e,n)=>{if(void 0!==t.$ref)return d.push({location:t.$ref,parent:e,name:n}),{}},y=util.aam(t.props||{},[g]),m=t=>"i"===t[1]||"o"===t[1]?i+t:t,w=d.map(t=>r.transaction.load(m(t.location),{partiallyInstalledCode:s})),b=await Promise.all(w);if(d.forEach(({location:t,parent:e,name:n},r)=>{e[n]=b[r]}),Object.assign(h,y),s.delete(e),this.aarc.has(e)){throw new Error(`Code installed twice for ${e}\n\n${"This is an internal Run bug. Please report it to the library developers."}.`)}return this.aarc.set(e,h),this.aarc.set(h,h),h}catch(t){throw u(t),t}}aahb(){this.aacd={aabc:[],aadc:new Set,aacc:new Set,aaec:new Map,aafc:new Map,error:null,aaac:!0,aazb:new Map,aagc:new WeakMap};const t={aacd:this.aacd,util:util};this.Jig=this.evaluate(Jig,Jig.toString(),"Jig",t,this.shouldSandbox("Jig"))[0],this.aarc.set(Jig,this.Jig),this.aarc.set(this.Jig,this.Jig)}shouldSandbox(t){return this.sandbox instanceof RegExp?this.sandbox.test(t):this.sandbox}evaluate(t,e,n,r,o){const s=this.aarc.get(t);if(s)return[s,null];const i=(o=o instanceof RegExp?o.test(n):o)?this.sandboxEvaluator:this.globalEvaluator,[a,c]=i.evaluate(e,r);return void 0===r.caller&&Object.defineProperty(c,"caller",{configurable:!0,enumerable:!0,get:()=>this.aacd.aabc.length<2?null:this.aacd.aazb.get(this.aacd.aabc[this.aacd.aabc.length-2])}),[!o&&t?t:a,c]}activate(t){const e=util.aas(t);this.aarc.forEach((t,n)=>{"string"!=typeof n&&(void 0!==n[`origin${e}`]?(n.origin=n[`origin${e}`],t.origin=n[`origin${e}`]):(delete n.origin,delete t.origin),void 0!==n[`location${e}`]?(n.location=n[`location${e}`],t.location=n[`location${e}`]):(delete n.location,delete t.location),void 0!==n[`owner${e}`]?(n.owner=n[`owner${e}`],t.owner=n[`owner${e}`]):(delete n.owner,delete t.owner))}),this.globalEvaluator.activate()}deactivate(){this.globalEvaluator.deactivate()}}const intrinsicDataTypes=["RegExp","Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Map","Set","WeakMap","WeakSet"],nonDeterministicGlobals=["Date","Math","eval","XMLHttpRequest","FileReader","WebSocket","setTimeout","setInterval"];class SESEvaluator{constructor(){this.realm=ses.makeSESRootRealm(),this.aayb={},intrinsicDataTypes.forEach(t=>{this.aayb[t]=this.realm.evaluate(t,{})});this.aayb.console=this.realm.evaluate("Object.assign(...Object.entries(c).map(([k, f]) => ({ [k]: (...a) => f(...a) })))",{c:console})}evaluate(t,e={}){if("string"!=typeof t)throw new Error(`Code must be a string. Received: ${t}`);if("object"!=typeof e)throw new Error(`Environment must be an object. Received: ${e}`);if("$globals"in e)throw new Error("Environment must not contain $globals");const n=this.realm.evaluate("({})");e=Object.assign({},this.aayb,e,{$globals:n}),nonDeterministicGlobals.forEach(t=>{t in e||(e[t]=void 0)});const r=t.startsWith("class")?"AnonymousClass":"anonymousFunction",o=`with($globals){'use strict';const ${r}=${t};${r}}`;return[this.realm.evaluate(o,e),n]}}class GlobalEvaluator{constructor(t={}){this.logger=t.logger,this.activated=!0,this.savedGlobalDescriptors={}}evaluate(code,env={}){if("string"!=typeof code)throw new Error(`Code must be a string. Received: ${code}`);if("object"!=typeof env)throw new Error(`Environment must be an object. Received: ${env}`);if("$globals"in env)throw new Error("Environment must not contain $globals");const anon=code.startsWith("class")?"AnonymousClass":"anonymousFunction",options={configurable:!0,enumerable:!0,writable:!0};Object.keys(env).forEach(t=>this.setGlobalDescriptor(t,Object.assign({},options,{value:env[t]})));const result=eval(`const ${anon} = ${code}; ${anon}`),wrappedGlobal=new Proxy(global,{set:(t,e,n)=>(this.setGlobalDescriptor(e,Object.assign({},options,{value:n})),!0),defineProperty:(t,e,n)=>(this.setGlobalDescriptor(e,n),!0)});return[result,wrappedGlobal]}setGlobalDescriptor(t,e){const n=Object.getOwnPropertyDescriptor(global,t);if(t in this.savedGlobalDescriptors){if(!sameDescriptors(e,n)&&this.logger){const e="There might be bugs with sandboxing disabled",n=`Two different values were set at the global scope for ${t}`;this.logger.warn(`${e}\n\n${n}`)}}else this.savedGlobalDescriptors[t]=n;Object.defineProperty(global,t,e)}activate(){this.activated||(this.swapSavedGlobals(),this.activated=!0)}deactivate(){this.activated&&(this.swapSavedGlobals(),this.activated=!1)}swapSavedGlobals(){const t={};Object.keys(this.savedGlobalDescriptors).forEach(e=>{t[e]=Object.getOwnPropertyDescriptor(global,e),void 0===this.savedGlobalDescriptors[e]?delete global[e]:Object.defineProperty(global,e,this.savedGlobalDescriptors[e])}),this.savedGlobalDescriptors=t}}function sameDescriptors(t,e){if(typeof t!=typeof e)return!1;const n=Array.from(Object.keys(t)),r=Array.from(Object.keys(e));return n.length===r.length&&!n.some(n=>t[n]!==e[n])}Code.SESEvaluator=SESEvaluator,Code.GlobalEvaluator=GlobalEvaluator,Code.intrinsicDataTypes=intrinsicDataTypes,Code.nonDeterministicGlobals=nonDeterministicGlobals,module.exports=Code}).call(this,__webpack_require__(4))},function(t,e,n){"use strict";(function(t){var r=n(19),o=n(20),s=n(21);function i(){return c.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(t,e){if(i()<e)throw new RangeError("Invalid typed array length");return c.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=c.prototype:(null===t&&(t=new c(e)),t.length=e),t}function c(t,e,n){if(!(c.TYPED_ARRAY_SUPPORT||this instanceof c))return new c(t,e,n);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return h(this,t)}return l(this,t,e,n)}function l(t,e,n,r){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,n,r){if(e.byteLength,n<0||e.byteLength<n)throw new RangeError("'offset' is out of bounds");if(e.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");e=void 0===n&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,n):new Uint8Array(e,n,r);c.TYPED_ARRAY_SUPPORT?(t=e).__proto__=c.prototype:t=p(t,e);return t}(t,e,n,r):"string"==typeof e?function(t,e,n){"string"==typeof n&&""!==n||(n="utf8");if(!c.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|d(e,n),o=(t=a(t,r)).write(e,n);o!==r&&(t=t.slice(0,o));return t}(t,e,n):function(t,e){if(c.isBuffer(e)){var n=0|f(e.length);return 0===(t=a(t,n)).length?t:(e.copy(t,0,0,n),t)}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(r=e.length)!=r?a(t,0):p(t,e);if("Buffer"===e.type&&s(e.data))return p(t,e.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function u(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function h(t,e){if(u(e),t=a(t,e<0?0:0|f(e)),!c.TYPED_ARRAY_SUPPORT)for(var n=0;n<e;++n)t[n]=0;return t}function p(t,e){var n=e.length<0?0:0|f(e.length);t=a(t,n);for(var r=0;r<n;r+=1)t[r]=255&e[r];return t}function f(t){if(t>=i())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i().toString(16)+" bytes");return 0|t}function d(t,e){if(c.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var n=t.length;if(0===n)return 0;for(var r=!1;;)switch(e){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return B(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return L(t).length;default:if(r)return B(t).length;e=(""+e).toLowerCase(),r=!0}}function g(t,e,n){var r=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return P(this,e,n);case"utf8":case"utf-8":return T(this,e,n);case"ascii":return O(this,e,n);case"latin1":case"binary":return k(this,e,n);case"base64":return A(this,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return I(this,e,n);default:if(r)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),r=!0}}function y(t,e,n){var r=t[e];t[e]=t[n],t[n]=r}function m(t,e,n,r,o){if(0===t.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=o?0:t.length-1),n<0&&(n=t.length+n),n>=t.length){if(o)return-1;n=t.length-1}else if(n<0){if(!o)return-1;n=0}if("string"==typeof e&&(e=c.from(e,r)),c.isBuffer(e))return 0===e.length?-1:w(t,e,n,r,o);if("number"==typeof e)return e&=255,c.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,e,n):Uint8Array.prototype.lastIndexOf.call(t,e,n):w(t,[e],n,r,o);throw new TypeError("val must be string, number or Buffer")}function w(t,e,n,r,o){var s,i=1,a=t.length,c=e.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(t.length<2||e.length<2)return-1;i=2,a/=2,c/=2,n/=2}function l(t,e){return 1===i?t[e]:t.readUInt16BE(e*i)}if(o){var u=-1;for(s=n;s<a;s++)if(l(t,s)===l(e,-1===u?0:s-u)){if(-1===u&&(u=s),s-u+1===c)return u*i}else-1!==u&&(s-=s-u),u=-1}else for(n+c>a&&(n=a-c),s=n;s>=0;s--){for(var h=!0,p=0;p<c;p++)if(l(t,s+p)!==l(e,p)){h=!1;break}if(h)return s}return-1}function b(t,e,n,r){n=Number(n)||0;var o=t.length-n;r?(r=Number(r))>o&&(r=o):r=o;var s=e.length;if(s%2!=0)throw new TypeError("Invalid hex string");r>s/2&&(r=s/2);for(var i=0;i<r;++i){var a=parseInt(e.substr(2*i,2),16);if(isNaN(a))return i;t[n+i]=a}return i}function E(t,e,n,r){return G(B(e,t.length-n),t,n,r)}function v(t,e,n,r){return G(function(t){for(var e=[],n=0;n<t.length;++n)e.push(255&t.charCodeAt(n));return e}(e),t,n,r)}function S(t,e,n,r){return v(t,e,n,r)}function x(t,e,n,r){return G(L(e),t,n,r)}function j(t,e,n,r){return G(function(t,e){for(var n,r,o,s=[],i=0;i<t.length&&!((e-=2)<0);++i)n=t.charCodeAt(i),r=n>>8,o=n%256,s.push(o),s.push(r);return s}(e,t.length-n),t,n,r)}function A(t,e,n){return 0===e&&n===t.length?r.fromByteArray(t):r.fromByteArray(t.slice(e,n))}function T(t,e,n){n=Math.min(t.length,n);for(var r=[],o=e;o<n;){var s,i,a,c,l=t[o],u=null,h=l>239?4:l>223?3:l>191?2:1;if(o+h<=n)switch(h){case 1:l<128&&(u=l);break;case 2:128==(192&(s=t[o+1]))&&(c=(31&l)<<6|63&s)>127&&(u=c);break;case 3:s=t[o+1],i=t[o+2],128==(192&s)&&128==(192&i)&&(c=(15&l)<<12|(63&s)<<6|63&i)>2047&&(c<55296||c>57343)&&(u=c);break;case 4:s=t[o+1],i=t[o+2],a=t[o+3],128==(192&s)&&128==(192&i)&&128==(192&a)&&(c=(15&l)<<18|(63&s)<<12|(63&i)<<6|63&a)>65535&&c<1114112&&(u=c)}null===u?(u=65533,h=1):u>65535&&(u-=65536,r.push(u>>>10&1023|55296),u=56320|1023&u),r.push(u),o+=h}return function(t){var e=t.length;if(e<=4096)return String.fromCharCode.apply(String,t);var n="",r=0;for(;r<e;)n+=String.fromCharCode.apply(String,t.slice(r,r+=4096));return n}(r)}e.Buffer=c,e.SlowBuffer=function(t){+t!=t&&(t=0);return c.alloc(+t)},e.INSPECT_MAX_BYTES=50,c.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=i(),c.poolSize=8192,c._augment=function(t){return t.__proto__=c.prototype,t},c.from=function(t,e,n){return l(null,t,e,n)},c.TYPED_ARRAY_SUPPORT&&(c.prototype.__proto__=Uint8Array.prototype,c.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&c[Symbol.species]===c&&Object.defineProperty(c,Symbol.species,{value:null,configurable:!0})),c.alloc=function(t,e,n){return function(t,e,n,r){return u(e),e<=0?a(t,e):void 0!==n?"string"==typeof r?a(t,e).fill(n,r):a(t,e).fill(n):a(t,e)}(null,t,e,n)},c.allocUnsafe=function(t){return h(null,t)},c.allocUnsafeSlow=function(t){return h(null,t)},c.isBuffer=function(t){return!(null==t||!t._isBuffer)},c.compare=function(t,e){if(!c.isBuffer(t)||!c.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var n=t.length,r=e.length,o=0,s=Math.min(n,r);o<s;++o)if(t[o]!==e[o]){n=t[o],r=e[o];break}return n<r?-1:r<n?1:0},c.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(t,e){if(!s(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return c.alloc(0);var n;if(void 0===e)for(e=0,n=0;n<t.length;++n)e+=t[n].length;var r=c.allocUnsafe(e),o=0;for(n=0;n<t.length;++n){var i=t[n];if(!c.isBuffer(i))throw new TypeError('"list" argument must be an Array of Buffers');i.copy(r,o),o+=i.length}return r},c.byteLength=d,c.prototype._isBuffer=!0,c.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)y(this,e,e+1);return this},c.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)y(this,e,e+3),y(this,e+1,e+2);return this},c.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)y(this,e,e+7),y(this,e+1,e+6),y(this,e+2,e+5),y(this,e+3,e+4);return this},c.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?T(this,0,t):g.apply(this,arguments)},c.prototype.equals=function(t){if(!c.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===c.compare(this,t)},c.prototype.inspect=function(){var t="",n=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(t+=" ... ")),"<Buffer "+t+">"},c.prototype.compare=function(t,e,n,r,o){if(!c.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===n&&(n=t?t.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),e<0||n>t.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&e>=n)return 0;if(r>=o)return-1;if(e>=n)return 1;if(this===t)return 0;for(var s=(o>>>=0)-(r>>>=0),i=(n>>>=0)-(e>>>=0),a=Math.min(s,i),l=this.slice(r,o),u=t.slice(e,n),h=0;h<a;++h)if(l[h]!==u[h]){s=l[h],i=u[h];break}return s<i?-1:i<s?1:0},c.prototype.includes=function(t,e,n){return-1!==this.indexOf(t,e,n)},c.prototype.indexOf=function(t,e,n){return m(this,t,e,n,!0)},c.prototype.lastIndexOf=function(t,e,n){return m(this,t,e,n,!1)},c.prototype.write=function(t,e,n,r){if(void 0===e)r="utf8",n=this.length,e=0;else if(void 0===n&&"string"==typeof e)r=e,n=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var o=this.length-e;if((void 0===n||n>o)&&(n=o),t.length>0&&(n<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var s=!1;;)switch(r){case"hex":return b(this,t,e,n);case"utf8":case"utf-8":return E(this,t,e,n);case"ascii":return v(this,t,e,n);case"latin1":case"binary":return S(this,t,e,n);case"base64":return x(this,t,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return j(this,t,e,n);default:if(s)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),s=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function O(t,e,n){var r="";n=Math.min(t.length,n);for(var o=e;o<n;++o)r+=String.fromCharCode(127&t[o]);return r}function k(t,e,n){var r="";n=Math.min(t.length,n);for(var o=e;o<n;++o)r+=String.fromCharCode(t[o]);return r}function P(t,e,n){var r=t.length;(!e||e<0)&&(e=0),(!n||n<0||n>r)&&(n=r);for(var o="",s=e;s<n;++s)o+=M(t[s]);return o}function I(t,e,n){for(var r=t.slice(e,n),o="",s=0;s<r.length;s+=2)o+=String.fromCharCode(r[s]+256*r[s+1]);return o}function _(t,e,n){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>n)throw new RangeError("Trying to access beyond buffer length")}function $(t,e,n,r,o,s){if(!c.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>o||e<s)throw new RangeError('"value" argument is out of bounds');if(n+r>t.length)throw new RangeError("Index out of range")}function R(t,e,n,r){e<0&&(e=65535+e+1);for(var o=0,s=Math.min(t.length-n,2);o<s;++o)t[n+o]=(e&255<<8*(r?o:1-o))>>>8*(r?o:1-o)}function C(t,e,n,r){e<0&&(e=4294967295+e+1);for(var o=0,s=Math.min(t.length-n,4);o<s;++o)t[n+o]=e>>>8*(r?o:3-o)&255}function N(t,e,n,r,o,s){if(n+r>t.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function F(t,e,n,r,s){return s||N(t,0,n,4),o.write(t,e,n,r,23,4),n+4}function U(t,e,n,r,s){return s||N(t,0,n,8),o.write(t,e,n,r,52,8),n+8}c.prototype.slice=function(t,e){var n,r=this.length;if((t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t),c.TYPED_ARRAY_SUPPORT)(n=this.subarray(t,e)).__proto__=c.prototype;else{var o=e-t;n=new c(o,void 0);for(var s=0;s<o;++s)n[s]=this[s+t]}return n},c.prototype.readUIntLE=function(t,e,n){t|=0,e|=0,n||_(t,e,this.length);for(var r=this[t],o=1,s=0;++s<e&&(o*=256);)r+=this[t+s]*o;return r},c.prototype.readUIntBE=function(t,e,n){t|=0,e|=0,n||_(t,e,this.length);for(var r=this[t+--e],o=1;e>0&&(o*=256);)r+=this[t+--e]*o;return r},c.prototype.readUInt8=function(t,e){return e||_(t,1,this.length),this[t]},c.prototype.readUInt16LE=function(t,e){return e||_(t,2,this.length),this[t]|this[t+1]<<8},c.prototype.readUInt16BE=function(t,e){return e||_(t,2,this.length),this[t]<<8|this[t+1]},c.prototype.readUInt32LE=function(t,e){return e||_(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},c.prototype.readUInt32BE=function(t,e){return e||_(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},c.prototype.readIntLE=function(t,e,n){t|=0,e|=0,n||_(t,e,this.length);for(var r=this[t],o=1,s=0;++s<e&&(o*=256);)r+=this[t+s]*o;return r>=(o*=128)&&(r-=Math.pow(2,8*e)),r},c.prototype.readIntBE=function(t,e,n){t|=0,e|=0,n||_(t,e,this.length);for(var r=e,o=1,s=this[t+--r];r>0&&(o*=256);)s+=this[t+--r]*o;return s>=(o*=128)&&(s-=Math.pow(2,8*e)),s},c.prototype.readInt8=function(t,e){return e||_(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},c.prototype.readInt16LE=function(t,e){e||_(t,2,this.length);var n=this[t]|this[t+1]<<8;return 32768&n?4294901760|n:n},c.prototype.readInt16BE=function(t,e){e||_(t,2,this.length);var n=this[t+1]|this[t]<<8;return 32768&n?4294901760|n:n},c.prototype.readInt32LE=function(t,e){return e||_(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},c.prototype.readInt32BE=function(t,e){return e||_(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},c.prototype.readFloatLE=function(t,e){return e||_(t,4,this.length),o.read(this,t,!0,23,4)},c.prototype.readFloatBE=function(t,e){return e||_(t,4,this.length),o.read(this,t,!1,23,4)},c.prototype.readDoubleLE=function(t,e){return e||_(t,8,this.length),o.read(this,t,!0,52,8)},c.prototype.readDoubleBE=function(t,e){return e||_(t,8,this.length),o.read(this,t,!1,52,8)},c.prototype.writeUIntLE=function(t,e,n,r){(t=+t,e|=0,n|=0,r)||$(this,t,e,n,Math.pow(2,8*n)-1,0);var o=1,s=0;for(this[e]=255&t;++s<n&&(o*=256);)this[e+s]=t/o&255;return e+n},c.prototype.writeUIntBE=function(t,e,n,r){(t=+t,e|=0,n|=0,r)||$(this,t,e,n,Math.pow(2,8*n)-1,0);var o=n-1,s=1;for(this[e+o]=255&t;--o>=0&&(s*=256);)this[e+o]=t/s&255;return e+n},c.prototype.writeUInt8=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,1,255,0),c.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},c.prototype.writeUInt16LE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):R(this,t,e,!0),e+2},c.prototype.writeUInt16BE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):R(this,t,e,!1),e+2},c.prototype.writeUInt32LE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):C(this,t,e,!0),e+4},c.prototype.writeUInt32BE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):C(this,t,e,!1),e+4},c.prototype.writeIntLE=function(t,e,n,r){if(t=+t,e|=0,!r){var o=Math.pow(2,8*n-1);$(this,t,e,n,o-1,-o)}var s=0,i=1,a=0;for(this[e]=255&t;++s<n&&(i*=256);)t<0&&0===a&&0!==this[e+s-1]&&(a=1),this[e+s]=(t/i>>0)-a&255;return e+n},c.prototype.writeIntBE=function(t,e,n,r){if(t=+t,e|=0,!r){var o=Math.pow(2,8*n-1);$(this,t,e,n,o-1,-o)}var s=n-1,i=1,a=0;for(this[e+s]=255&t;--s>=0&&(i*=256);)t<0&&0===a&&0!==this[e+s+1]&&(a=1),this[e+s]=(t/i>>0)-a&255;return e+n},c.prototype.writeInt8=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,1,127,-128),c.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},c.prototype.writeInt16LE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):R(this,t,e,!0),e+2},c.prototype.writeInt16BE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):R(this,t,e,!1),e+2},c.prototype.writeInt32LE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,4,2147483647,-2147483648),c.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):C(this,t,e,!0),e+4},c.prototype.writeInt32BE=function(t,e,n){return t=+t,e|=0,n||$(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):C(this,t,e,!1),e+4},c.prototype.writeFloatLE=function(t,e,n){return F(this,t,e,!0,n)},c.prototype.writeFloatBE=function(t,e,n){return F(this,t,e,!1,n)},c.prototype.writeDoubleLE=function(t,e,n){return U(this,t,e,!0,n)},c.prototype.writeDoubleBE=function(t,e,n){return U(this,t,e,!1,n)},c.prototype.copy=function(t,e,n,r){if(n||(n=0),r||0===r||(r=this.length),e>=t.length&&(e=t.length),e||(e=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),t.length-e<r-n&&(r=t.length-e+n);var o,s=r-n;if(this===t&&n<e&&e<r)for(o=s-1;o>=0;--o)t[o+e]=this[o+n];else if(s<1e3||!c.TYPED_ARRAY_SUPPORT)for(o=0;o<s;++o)t[o+e]=this[o+n];else Uint8Array.prototype.set.call(t,this.subarray(n,n+s),e);return s},c.prototype.fill=function(t,e,n,r){if("string"==typeof t){if("string"==typeof e?(r=e,e=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===t.length){var o=t.charCodeAt(0);o<256&&(t=o)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!c.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<n)throw new RangeError("Out of range index");if(n<=e)return this;var s;if(e>>>=0,n=void 0===n?this.length:n>>>0,t||(t=0),"number"==typeof t)for(s=e;s<n;++s)this[s]=t;else{var i=c.isBuffer(t)?t:B(new c(t,r).toString()),a=i.length;for(s=0;s<n-e;++s)this[s+e]=i[s%a]}return this};var D=/[^+\/0-9A-Za-z-_]/g;function M(t){return t<16?"0"+t.toString(16):t.toString(16)}function B(t,e){var n;e=e||1/0;for(var r=t.length,o=null,s=[],i=0;i<r;++i){if((n=t.charCodeAt(i))>55295&&n<57344){if(!o){if(n>56319){(e-=3)>-1&&s.push(239,191,189);continue}if(i+1===r){(e-=3)>-1&&s.push(239,191,189);continue}o=n;continue}if(n<56320){(e-=3)>-1&&s.push(239,191,189),o=n;continue}n=65536+(o-55296<<10|n-56320)}else o&&(e-=3)>-1&&s.push(239,191,189);if(o=null,n<128){if((e-=1)<0)break;s.push(n)}else if(n<2048){if((e-=2)<0)break;s.push(n>>6|192,63&n|128)}else if(n<65536){if((e-=3)<0)break;s.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;s.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return s}function L(t){return r.toByteArray(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(D,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function G(t,e,n,r){for(var o=0;o<r&&!(o+n>=e.length||o>=t.length);++o)e[o+n]=t[o];return o}}).call(this,n(4))},function(t,e,n){(function(e){const r=n(1),util=n(2),o=n(6);class s{constructor(t){this.aaid=t,this.reset()}reset(){this.code=[],this.actions=[],this.stateBefore=new Map,this.stateAfter=new Map,this.inputs=[],this.outputs=[],this.aacc=new Set,this.aazb=new Map,this.locations=new Map,this.aauc=0,this.imported=!1}async import(t,e,s,i,a,c){if(this.code.length||this.code.actions||this.aauc)throw new Error("transaction already in progress. cannot import.");for(let n=0;n<t.inputs.length;n++){const o=t.inputs[n];if(!o.output){const t=await e.blockchain.fetch(o.prevTxId.toString("hex"));if(!t.outputs[o.outputIndex].script.isPublicKeyHashOut())throw new Error(`Unsupported script type at input ${n}`);o.output=t.outputs[o.outputIndex],Reflect.setPrototypeOf(o,r.Transaction.Input.PublicKeyHash.prototype)}}this.aauc=1,this.imported=!0;const l=util.aaf(t),u=util.bsvNetwork(e.blockchain.network);let h=1;for(const n of l.code){const r=`${t.hash}_o${h++}`;await e.code.aagb(n,r,t,e,u,c)}if(a&&a>0&&a<1+l.code.length)return void(this.code=new Array(l.code.length));const p=new Map;l.refs&&l.refs.forEach(t=>p.set(t,t));for(const e of l.actions){const n=e=>{if("_"!==e[0]&&p.set(e,e),"i"===e[1]){const n=t.inputs[parseInt(e.slice(2))];p.set(e,`${n.prevTxId.toString("hex")}_o${n.outputIndex}`)}};e.target&&"init"!==e.method&&n(e.target);const r=t=>{t&&void 0!==t.$ref&&n(t.$ref)};util.aap(e.args,r)}for(const[,n]of p){const r=await e.blockchain.fetch(n.slice(0,64)),o=parseInt(n.slice(66));if(void 0===r.outputs[o].spentTxId)throw new Error("Cannot check if read is stale. Blockchain API does not support spentTxId.");if(null===r.outputs[o].spentTxId)continue;const s=await e.blockchain.fetch(r.outputs[o].spentTxId);if(s.time<=t.time&&s.time>=r.time&&t.time-r.time>72e5&&t.hash!==s.hash)throw new Error(`${n} is stale. Aborting.`)}for(const[t,n]of p)if(s&&n===s.location)p.set(t,s);else try{p.set(t,await e.transaction.load(n))}catch(r){throw e.logger.error(r),new Error(`Error loading ref ${t} at ${n}\n\n${r}`)}s&&p.set(s.location,s);const{Jig:Jig}=n(3),f=t=>{e.code.aacd.aaac=!1;util.aap(t,(t,e,n)=>{if(t&&t instanceof Jig){if(!e)return;const r=Array.from(p.values()).find(e=>e.origin===t.origin);r&&(e[n]=r)}}),e.code.aacd.aaac=!0};for(const t of p.values())f(t);for(const n of l.actions){const r=t=>{if(void 0!==t.$ref){if("_"!==t.$ref[0]||"i"===t.$ref[1]){const e=p.get(t.$ref);if(!e)throw new Error(`unexpected ref ${t.$ref}`);return e}if("r"===t.$ref[1]){const e=p.get(l.refs[parseInt(t.$ref.slice(2))]);if(!e)throw new Error(`unexpected ref ${t.$ref}`);return e}if("o"!==t.$ref[1])throw new Error(`unexpected ref ${t.$ref}`);const e=parseInt(t.$ref.slice(2))-1-l.code.length;return this.aazb.get(this.outputs[e])}};e.code.aacd.aaac=!1;const o=util.aam(n.args,[r]);if(e.code.aacd.aaac=!0,"init"===n.method){if("_"===n.target[0]){const t=parseInt(n.target.slice(2));if(t<=0||t>=l.code.length+1)throw new Error(`missing target ${n.target}`)}const r="_"===n.target[0]?t.hash+n.target:n.target,s=await e.transaction.load(r),i=e.transaction.aaob(this,n.creator);try{new s(...o)}finally{e.transaction.aaob(i.aatc,i.creator)}}else{const t=p.get(n.target)||this.aazb.get(this.outputs[parseInt(n.target.slice(2))-1-l.code.length]);if(f(t),void 0===t)throw new Error(`target ${n.target} missing`);const r=e.transaction.aaob(this,null);try{t[n.method](...o)}catch(t){throw new Error(`unexpected exception in ${n.method}\n\n${t}`)}finally{e.transaction.aaob(r.aatc,r.creator)}}}const d=this.inputs.filter(t=>"_"!==t.origin[0]);if(l.jigs!==this.outputs.length)throw new Error("bad number of jigs");if(t.inputs.length<d.length)throw new Error("not enough inputs");if(t.outputs.length<l.code.length+l.jigs+1)throw new Error("not enough outputs");d.forEach((e,n)=>{if(`${t.inputs[n].prevTxId.toString("hex")}_o${t.inputs[n].outputIndex}`!==(this.locations.get(e.origin)||e.location))throw new Error(`bad input ${n}`)}),this.outputs.forEach((e,n)=>{const o=1+l.code.length+n;if(new r.PublicKey(e.owner,{network:u}).toAddress().toString()!==t.outputs[o].script.toAddress(u).toString())throw new Error(`bad owner on output ${o}`);if(t.outputs[o].satoshis<Math.max(e.satoshis,r.Transaction.DUST_AMOUNT))throw new Error(`bad satoshis on output ${o}`)}),i&&this.outputs.forEach(e=>{const n=`${t.hash}_o${1+l.code.length+parseInt(e.location.slice(2))}`;"_"===e.origin[0]&&(e.origin=n),"_"===e.location[0]&&(e.location=n)});const g=this.outputs.map(t=>this.aazb.get(t)),y=new Array(1+l.code.length).concat(g),m=util.aas(e.blockchain.network);for(let n=0;n<y.length;n++){if(!y[n])continue;const r=`${t.hash.slice(0,64)}_o${n}`;e.code.aacd.aaac=!1;const o=util.aal(Object.assign({},y[n]),[e=>{if(e instanceof Jig||util.aai(e))return e.location.startsWith(t.hash)?{$ref:e.location.slice(64)}:{$ref:e.location}}]);e.code.aacd.aaac=!0,o.origin.startsWith(t.hash)&&delete o.origin,o.location.startsWith(t.hash)&&delete o.location;let s=y[n].constructor[`origin${m}`];s.startsWith(t.hash)&&(s=s.slice(64));const i={type:s,state:o};await e.state.set(r,i)}this.code=[],l.code.forEach((n,r)=>{const s=`${t.hash}_o${r+1}`,i=e.code.aafb(s);this.aamb(i,i,{},o.aahd(i).props,()=>{},()=>{},n.owner,e.code,e)});const w=d.map(t=>this.locations.get(t.origin)||t.location);this.aavc={tx:t,refs:l.refs||[],aajd:d,aakd:w}}begin(){this.aauc++}end(){if(0===this.aauc)throw new Error("end transaction without begin");0==--this.aauc&&this.aaid&&(this.code.length||this.actions.length)&&this.aaid()}rollback(t,e,n,r){delete this.aavc,this.code.forEach(t=>t.error()),this.code.forEach(t=>e.owner.aavb(t.sandbox)),this.outputs.forEach(e=>{if("_"===e.origin[0]||r){const t=`!${"_"===e.origin[0]?"deploy failed":"a previous update failed"}\n\n${n}`;return Object.keys(e).forEach(t=>delete e[t]),void(e.origin=e.location=t)}if("_"!==e.location[0])return;const o=e.origin;Object.keys(e).forEach(t=>delete e[t]);const s=util.aao(this.stateBefore.get(e).refs);Object.assign(e,util.aam(this.stateBefore.get(e).json,[s])),e.origin=o,e.location=t.get(o)}),this.outputs.forEach(t=>e.owner.aavb(this.aazb.get(t))),this.reset()}aamb(t,e,n,r,o,s,i,a,c){delete this.aavc,this.begin();try{this.code.push({type:t,sandbox:e,deps:n,props:r,success:o,error:s,owner:i});const l=`_d${this.code.length-1}`;return t.owner=e.owner=i,c.owner.aavb(a.aafb(t)),l}finally{this.end()}}aanb(t,e,n,r,o,s,i,a,c,l){delete this.aavc,this.begin();try{const l=new Map,u=t=>{const e=t=>void 0!==t.origin&&"_"!==t.origin[0],n=l.get(e(t)?t.origin:t);if(!n)return l.set(e(t)?t.origin:t,t.location);if(n!==t.location)throw new Error(`referenced different locations of same jig: ${t}`)};u(t),r.forEach(t=>u(t)),o.forEach(t=>u(t)),s.forEach(t=>u(t)),i.forEach((t,e)=>{this.stateBefore.set(e,this.stateBefore.get(e)||t)}),a.forEach((t,e)=>{this.stateAfter.set(e,t)}),r.forEach(t=>{if(this.inputs.some(e=>util.aar(t,e)&&e.location!==t.location))throw new Error("different instances of the same jig");this.inputs.some(e=>util.aar(t,e))||this.inputs.push(t)}),o.forEach(t=>{const e=this.outputs.findIndex(e=>util.aar(t,e));if(-1!==e)return t.location=`_o${e}`,void(t.origin=t.origin||t.location);this.outputs.push(t);(t=>t.origin&&"_"!==t.origin[0]&&t.location&&"_"!==t.location[0]&&!this.locations.has(t.origin))(t)&&this.locations.set(t.origin,t.location),t.location=`_o${this.outputs.length-1}`,t.origin=t.origin||t.location}),s.forEach(t=>this.aacc.add(t)),c.forEach((t,e)=>this.aazb.set(e,t));const h=i.get(t).json.owner;this.actions.push({target:t,method:e,creator:h,args:n,inputs:r,outputs:o,aacc:s})}finally{this.end()}o.forEach(t=>l.owner.aavb(c.get(t)))}async pay(t){return this.aavc||this.aapb(t),t.purse.pay(this.aavc.tx)}async sign(t){return this.aavc||this.aapb(t),t.owner.sign(this.aavc.tx)}aapb(t){if(this.aavc)return this.aavc;const{blockchain:o,aasc:s}=t,i=util.aas(o.network),a=util.bsvNetwork(o.network),c=this.inputs.filter(t=>"_"!==t.origin[0]),l=new Map;this.aacc.forEach(t=>{if(c.includes(t)||this.outputs.includes(t))return;const e=s.aayc.get(t.origin)||this.locations.get(t.origin)||t.location,n=l.get(t.origin);if(n&&n!==e)throw new Error(`read different locations of same jig ${t.origin}`);l.set(t.origin,e)});const u=Array.from(l.values()),{Jig:Jig}=n(3),h=t=>{if(t instanceof Jig){const e=Array.from(this.aazb.entries()).filter(([e,n])=>n===t).map(([t,e])=>t);e.length&&(t=e[0]);const n=c.findIndex(e=>util.aar(e,t));if(-1!==n)return{$ref:`_i${n}`};const r=this.outputs.findIndex(e=>util.aar(e,t));if(-1!==r)return{$ref:`_o${1+this.code.length+r}`};const o=u.indexOf(l.get(t.origin));return-1!==o?{$ref:`_r${o}`}:{$ref:s.aayc.get(t.origin)||t.location}}},p=t=>{if(util.aai(t)){return{$ref:"_"===t[`location${i}`][0]?`_o${parseInt(t[`location${i}`].slice(2))+1}`:t[`location${i}`]}}},f=this.actions.map(t=>{const{method:e}=t,n=util.aal(t.args,[h,p]);if("init"===e){const r=t.target.constructor[`origin${i}`]||t.target.constructor[`location${i}`];return{target:"_"===r[0]?`_o${1+parseInt(r.slice(2))}`:r,method:e,args:n,creator:t.creator}}const r=c.findIndex(e=>util.aar(e,t.target));if(-1!==r)return{target:`_i${r}`,method:e,args:n};const o=this.outputs.findIndex(e=>util.aar(e,t.target));return-1!==o?{target:`_o${1+this.code.length+o}`,method:e,args:n}:{target:"_"!==t.target.location[0]?t.target.location:s.aayc.get(t.target.origin),method:e,args:n}}),d={code:this.code.map(t=>{const e=Object.entries(t.deps).map(([t,e])=>{return{[t]:(n=e[`location${i}`],"_"===n[0]?`_o${1+parseInt(n.slice(2))}`:n)};var n}),n=e.length?Object.assign(...e):void 0;let r;return Object.keys(t.props).length&&(r=util.aal(t.props,[h,p])),{text:util.aah(t.type),deps:n,props:r,owner:t.owner}}),actions:f,jigs:this.outputs.length,refs:u.length?u:void 0},g=util.aaj(d),y=e.from("run","utf8"),m=e.from([util.aaed],"hex"),w=e.from(t.app,"utf8"),b=e.from(g,"utf8"),E=e.from("r11r","utf8"),v=r.Script.buildSafeDataOut([y,m,w,b,E]),S=(new r.Transaction).addOutput(new r.Transaction.Output({script:v,satoshis:0})),x=c.map(t=>s.aayc.get(t.origin)||this.locations.get(t.origin)||t.location);c.forEach((t,e)=>{const n=x[e].slice(0,64),o=parseInt(x[e].slice(66)),s=this.stateBefore.get(t),i=Math.max(r.Transaction.DUST_AMOUNT,s.json.satoshis),c=new r.PublicKey(s.json.owner,{network:a}),l={txid:n,vout:o,script:r.Script.buildPublicKeyHashOut(c),satoshis:i};S.from(l)});return this.code.forEach(t=>S.to((t=>new r.PublicKey(t.owner,{network:a}))(t),r.Transaction.DUST_AMOUNT)),this.outputs.forEach(t=>{const e=this.stateAfter.get(t).json.owner,n=new r.PublicKey(e,{network:a}).toAddress(),o=this.stateAfter.get(t).json.satoshis;S.to(n,Math.max(r.Transaction.DUST_AMOUNT,o))}),this.aavc={tx:S,refs:u,aajd:c,aakd:x},this.aavc}}t.exports={aadd:s,Transaction:class{constructor(t){this.run=t,this.aasc=t.aasc,this.blockchain=t.blockchain,this.state=t.state,this.owner=t.owner.pubkey?t.owner.pubkey:null,this.code=t.code,this.aatc=new s(this.aaid.bind(this))}begin(){return this.aatc.begin(),this.run}end(){return this.aatc.end(),this.run}aaid(){this.aasc.aalb(this.aatc),this.aatc=new s(this.aaid.bind(this))}export(){if(this.aasc.aazc.length>0)throw new Error("must not have any queued transactions before exporting");if(0===this.aatc.aauc){throw new Error(`No transaction in progress\n\n${"Hint: A transaction must first be created using begin() or loaded using import()."}`)}return this.aatc.aapb(this.run).tx}import(t){return this.aatc.import(t,this.run,!1)}rollback(){this.aatc.rollback(this.aasc.aayc,this.run,!1,"intentional rollback")}async sign(){await this.aatc.sign(this.run)}async pay(){await this.aatc.pay(this.run)}get actions(){return this.aatc.actions.map(t=>({target:this.aatc.aazb.get(t.target),method:t.method,args:t.args}))}aamb(t,e,n,r,o,s){return this.aatc.aamb(t,e,n,r,o,s,this.owner,this.code,this.run)}aanb(t,e,n,r,o,s,i,a,c,l){this.aatc.aanb(t,e,n,r,o,s,i,a,c,this.run)}async load(t,e={}){this.run.logger&&this.run.logger.info("Loading",t);const n=e.cachedRefs||new Map;if("string"!=typeof t)throw new Error(`typeof location is ${typeof t} - must be string`);const r=this.code.aafb(t);if(r)return r;if(e.partiallyInstalledCode&&e.partiallyInstalledCode.has(t))return e.partiallyInstalledCode.get(t);const o=t.slice(0,64);if("_"!==t[64])throw new Error(`Bad location: ${t}`);if("i"===t[65]){const e=await this.blockchain.fetch(o),n=parseInt(t.slice(66)),r=e.inputs[n].prevTxId.toString("hex");return this.load(`${r}_o${e.inputs[n].outputIndex}`)}const i=parseInt(t.slice(66));if("o"!==t[65]||isNaN(i))throw new Error(`Bad location: ${t}`);const a=await this.state.get(t);if(a){if("string"!=typeof a.type||"object"!=typeof a.state){const t="Hint: Could the state cache be corrupted?";throw new Error(`Cached state is missing a valid type and/or state property\n\n${JSON.stringify(a)}\n\n${t}`)}const e=a.type.startsWith("_")?t.slice(0,64)+a.type:a.type,r=await this.load(e),o=t=>{if(void 0!==t.$ref)return t};this.code.aacd.stateToInject=util.aam(a.state,[o]),this.code.aacd.stateToInject.origin=this.code.aacd.stateToInject.origin||t,this.code.aacd.stateToInject.location=this.code.aacd.stateToInject.location||t;const s=new r;this.code.aacd.stateToInject=null,n.set(t,s);const i=e=>e.startsWith("_")?`${t.slice(0,64)}${e}`:e;util.aap(a.state,t=>{if(t&&t.$ref){const e=i(t.$ref);n.has(e)||n.set(e,null)}});const c=new Map(n);for(const[t,e]of c){if(e)continue;const r=await this.load(t,{cachedRefs:n});n.has(t)&&n.set(t,r)}return this.code.aacd.aaac=!1,util.aap(s,(t,e,r)=>{t&&t.$ref&&(e[r]=n.get(i(t.$ref)))}),this.code.aacd.aaac=!0,s}const c=new s,l=await this.blockchain.fetch(o);if(await c.import(l,this.run,null,!0,i,e.partiallyInstalledCode),i>0&&i<c.code.length+1)return this.code.aafb(t)||e.partiallyInstalledCode.get(t);const u=c.outputs.map(t=>c.aazb.get(t)),h=new Array(1+c.code.length).concat(u);if(void 0===h[i])throw new Error("not a jig output");return h[i]}aaob(t,e){const n={aatc:this.aatc,creator:this.owner};return this.aatc=t,this.owner=e,n}}}}).call(this,n(7).Buffer)},function(t,e,n){const{Address:r,Script:o,Transaction:s}=n(1),i=n(26),util=n(2);class a{get network(){throw new Error("Not implemented")}async broadcast(t){throw new Error("Not implemented")}async fetch(t,e){throw new Error("Not implemented")}async utxos(t){throw new Error("Not implemented")}}a.aahc=t=>!("object"!=typeof t||!t)&&("function"==typeof t.broadcast&&("function"==typeof t.fetch&&("function"==typeof t.utxos&&"string"==typeof t.network)));class c{constructor(t={}){this.network=function(t){if("main"===t||"test"===t||"stn"===t)return t;switch(typeof t){case"string":throw new Error(`Unknown network: ${t}`);case"undefined":return"main";default:throw new Error(`Invalid network: ${t}`)}}(t.network),this.logger=function(t){switch(typeof t){case"object":return t;case"undefined":return null;default:throw new Error(`Invalid logger: ${t}`)}}(t.logger),this.api=function(t){switch(typeof t){case"string":{const e=d.find(e=>e.name===t);if(!e)throw new Error(`Unknown blockchain API: ${t}`);return e}case"object":if(!t)throw new Error(`Invalid blockchain API: ${t}`);return t;case"undefined":return d[0];default:throw new Error(`Invalid blockchain API: ${t}`)}}(t.api),this.cache=function(t,e){if(t&&t instanceof c&&t.network===e)return t.cache;return new u}(t.lastBlockchain,this.network),this.axios=i.create({timeout:l(t.timeout)}),this.bsvNetwork=util.bsvNetwork(this.network),this.aaic=new Map}async broadcast(t){if(0===t.inputs.length)throw new Error("tx has no inputs");if(0===t.outputs.length)throw new Error("tx has no outputs");if(t.getFee()<t.toBuffer().length)throw new Error("tx fee too low");if(!0!==t.verify())throw new Error(t.verify());if(!0!==t.isFullySigned())throw new Error("tx not fully signed");t.time=Date.now(),t.confirmations=0,t.outputs.forEach(t=>{t.spentTxId=null,t.spentIndex=null,t.spentHeight=null}),await this._post(this.api.aau(this.network),this.api.aav(t)),this.cache.aadb(t)}async fetch(t,e=!1){const n=this.cache.get(t);if(!e&&n)return n;const r=this.aaic.get(t);if(r)return new Promise((t,e)=>r.push({resolve:t,reject:e}));this.aaic.set(t,[]);try{const e=(await this._get(this.api.aaw(this.network,t))).data,r=this.api.aax(e);if(n)for(let t=0;t<r.outputs.length;t++)r.outputs[t].spentTxId=r.outputs[t].spentTxId||n.outputs[t].spentTxId,r.outputs[t].spentIndex=r.outputs[t].spentIndex||n.outputs[t].spentIndex,r.outputs[t].spentHeight=r.outputs[t].spentHeight||n.outputs[t].spentHeight;return this.cache.aacb(r),this.aaic.get(t).forEach(t=>t.resolve(r)),r}catch(e){throw this.aaic.get(t).forEach(t=>t.reject(e)),e}finally{this.aaic.delete(t)}}async utxos(t){t=new r(t,this.bsvNetwork).toString();const e=this.aaic.get(t);if(e)return new Promise((t,n)=>e.push({resolve:t,reject:n}));this.aaic.set(t,[]);try{const e=(await this._get(this.api.aay(this.network,t))).data,n=this.api.aaz(e,t),r=this.aaab(n),o=this.cache.aabb(r,t);return this.aaic.get(t).forEach(t=>t.resolve(o)),o}catch(e){throw this.aaic.get(t).forEach(t=>t.reject(e)),e}finally{this.aaic.delete(t)}}aaab(t){const e=new Set;return t.filter(t=>{const n=`${t.txid}_o${t.vout}`;return e.has(n)?(this.logger&&this.logger.warn(`Duplicate utxo returned from server: ${n}`),!1):(e.add(n),!0)})}async _post(t,e){return this.logger&&this.logger.info(`POST ${t}`),h(this.axios.post(t,e))}async _get(t){return this.logger&&this.logger.info(`GET ${t}`),h(this.axios.get(t))}}function l(t){switch(typeof t){case"number":if(Number.isNaN(t)||t<0)throw new Error(`Invalid timeout: ${t}`);return t;case"undefined":return 1e4;default:throw new Error(`Invalid timeout: ${t}`)}}class u{constructor(){this.aanc=new Map,this.aajc=[],this.size=1e4,this.aakc=6e5,this.aalc=1e4}get(t){const e=this.aanc.get(t);if(e)return Date.now()-e.aamc>this.aakc?void this.aanc.delete(t):(this.aanc.delete(t),this.aanc.set(t,e),e)}aacb(t){if(t.aamc=Date.now(),this.aanc.set(t.hash,t),this.aanc.size>this.size){const t=this.aanc.keys().next().value;this.aanc.delete(t)}}aadb(t){this.aacb(t);const e=Date.now();this.aajc=this.aajc.filter(t=>e-t.time<this.aalc),this.aajc.push(t),t.inputs.forEach((e,n)=>{const r=this.aanc.get(e.prevTxId.toString("hex"));r&&(r.outputs[e.outputIndex].spentTxId=t.hash,r.outputs[e.outputIndex].spentIndex=n,r.outputs[e.outputIndex].spentHeight=-1)})}aabb(t,e){const n=Date.now();return this.aajc=this.aajc.filter(t=>n-t.time<this.aalc),this.aajc.forEach(n=>{n.outputs.forEach((r,o)=>{r.script.toAddress(this.bsvNetwork).toString()!==e||t.some(t=>t.txid===n.hash&&t.vout===o)||t.push({txid:n.hash,vout:o,script:r.script,satoshis:r.satoshis})})}),this.aajc.forEach(e=>{t=t.filter(t=>!e.inputs.some(e=>((t,e)=>t.prevTxId.toString("hex")===e.txid&&t.outputIndex===e.vout)(e,t)))}),t}}async function h(t){try{return await t}catch(t){const{config:e,response:n}=t;if(e&&e.url&&n&&n.data){const t=n.data.message?n.data.message.message||n.data.message:n.data,r=n.data.name&&t?`${n.data.name}: ${t}`:n.data.name||t;throw new Error(`${r}\n\n${e.method.toUpperCase()} ${e.url}`)}throw t}}function p(t){const e=new s(t.hex||t.rawtx);return e.time=1e3*t.time||Date.now(),t.blockhash&&t.blockhash.length&&(e.blockhash=t.blockhash),t.blocktime&&(e.blocktime=t.blocktime),t.blockheight&&(e.blockheight=t.blockheight),void 0!==t.confirmations&&(e.confirmations=t.confirmations),t.vout&&t.vout.forEach((t,n)=>{void 0!==t.spentTxId&&(e.outputs[n].spentTxId=t.spentTxId),void 0!==t.spentIndex&&(e.outputs[n].spentIndex=t.spentIndex),void 0!==t.spentHeight&&(e.outputs[n].spentHeight=t.spentHeight)}),e}const f="https://api.star.store",d=[{name:"star",aau:t=>`${f}/v1/${t}/tx`,aav:t=>({rawtx:t.toBuffer().toString("hex")}),aaw:(t,e)=>`${f}/v1/${t}/tx/${e}`,aax:t=>p(t),aay:(t,e)=>`${f}/v1/${t}/utxos/${e.toString()}`,aaz:(t,e)=>t},{name:"bitindex",aau:t=>`https://api.bitindex.network/api/v3/${t}/tx/send`,aav:t=>({rawtx:t.toBuffer().toString("hex")}),aaw:(t,e)=>`https://api.bitindex.network/api/v3/${t}/tx/${e}`,aax:t=>{const e=p(t);return e.confirmations=e.confirmations||0,e},aay:(t,e)=>`https://api.bitindex.network/api/v3/${t}/addr/${e.toString()}/utxo`,aaz:(t,e)=>t.map(t=>Object.assign({},t,{script:new o(t.scriptPubKey)}))},{name:"whatsonchain",aau:t=>`https://api.whatsonchain.com/v1/bsv/${t}/tx/raw`,aav:t=>({txhex:t.toBuffer().toString("hex")}),aaw:(t,e)=>`https://api.whatsonchain.com/v1/bsv/${t}/tx/hash/${e}`,aax:t=>{const e=p(t);return e.confirmations=e.confirmations||0,e},aay:(t,e)=>`https://api.whatsonchain.com/v1/bsv/${t}/address/${e.toString()}/unspent`,aaz:(t,e)=>t.map(t=>({txid:t.tx_hash,vout:t.tx_pos,satoshis:t.value,script:o.fromAddress(e)}))}];c.Cache=u,t.exports={Blockchain:a,BlockchainServer:c}},function(t,e,n){"use strict";t.exports=function(t,e){return function(){for(var n=new Array(arguments.length),r=0;r<n.length;r++)n[r]=arguments[r];return t.apply(e,n)}}},function(t,e,n){"use strict";var r=n(0);function o(t){return encodeURIComponent(t).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}t.exports=function(t,e,n){if(!e)return t;var s;if(n)s=n(e);else if(r.isURLSearchParams(e))s=e.toString();else{var i=[];r.forEach(e,(function(t,e){null!=t&&(r.isArray(t)?e+="[]":t=[t],r.forEach(t,(function(t){r.isDate(t)?t=t.toISOString():r.isObject(t)&&(t=JSON.stringify(t)),i.push(o(e)+"="+o(t))})))})),s=i.join("&")}if(s){var a=t.indexOf("#");-1!==a&&(t=t.slice(0,a)),t+=(-1===t.indexOf("?")?"?":"&")+s}return t}},function(t,e,n){"use strict";t.exports=function(t){return!(!t||!t.__CANCEL__)}},function(t,e,n){"use strict";(function(e){var r=n(0),o=n(34),s={"Content-Type":"application/x-www-form-urlencoded"};function i(t,e){!r.isUndefined(t)&&r.isUndefined(t["Content-Type"])&&(t["Content-Type"]=e)}var a,c={adapter:(void 0!==e&&"[object process]"===Object.prototype.toString.call(e)?a=n(14):"undefined"!=typeof XMLHttpRequest&&(a=n(14)),a),transformRequest:[function(t,e){return o(e,"Accept"),o(e,"Content-Type"),r.isFormData(t)||r.isArrayBuffer(t)||r.isBuffer(t)||r.isStream(t)||r.isFile(t)||r.isBlob(t)?t:r.isArrayBufferView(t)?t.buffer:r.isURLSearchParams(t)?(i(e,"application/x-www-form-urlencoded;charset=utf-8"),t.toString()):r.isObject(t)?(i(e,"application/json;charset=utf-8"),JSON.stringify(t)):t}],transformResponse:[function(t){if("string"==typeof t)try{t=JSON.parse(t)}catch(t){}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(t){return t>=200&&t<300}};c.headers={common:{Accept:"application/json, text/plain, */*"}},r.forEach(["delete","get","head"],(function(t){c.headers[t]={}})),r.forEach(["post","put","patch"],(function(t){c.headers[t]=r.merge(s)})),t.exports=c}).call(this,n(33))},function(t,e,n){"use strict";var r=n(0),o=n(35),s=n(11),i=n(37),a=n(38),c=n(15);t.exports=function(t){return new Promise((function(e,l){var u=t.data,h=t.headers;r.isFormData(u)&&delete h["Content-Type"];var p=new XMLHttpRequest;if(t.auth){var f=t.auth.username||"",d=t.auth.password||"";h.Authorization="Basic "+btoa(f+":"+d)}if(p.open(t.method.toUpperCase(),s(t.url,t.params,t.paramsSerializer),!0),p.timeout=t.timeout,p.onreadystatechange=function(){if(p&&4===p.readyState&&(0!==p.status||p.responseURL&&0===p.responseURL.indexOf("file:"))){var n="getAllResponseHeaders"in p?i(p.getAllResponseHeaders()):null,r={data:t.responseType&&"text"!==t.responseType?p.response:p.responseText,status:p.status,statusText:p.statusText,headers:n,config:t,request:p};o(e,l,r),p=null}},p.onabort=function(){p&&(l(c("Request aborted",t,"ECONNABORTED",p)),p=null)},p.onerror=function(){l(c("Network Error",t,null,p)),p=null},p.ontimeout=function(){l(c("timeout of "+t.timeout+"ms exceeded",t,"ECONNABORTED",p)),p=null},r.isStandardBrowserEnv()){var g=n(39),y=(t.withCredentials||a(t.url))&&t.xsrfCookieName?g.read(t.xsrfCookieName):void 0;y&&(h[t.xsrfHeaderName]=y)}if("setRequestHeader"in p&&r.forEach(h,(function(t,e){void 0===u&&"content-type"===e.toLowerCase()?delete h[e]:p.setRequestHeader(e,t)})),t.withCredentials&&(p.withCredentials=!0),t.responseType)try{p.responseType=t.responseType}catch(e){if("json"!==t.responseType)throw e}"function"==typeof t.onDownloadProgress&&p.addEventListener("progress",t.onDownloadProgress),"function"==typeof t.onUploadProgress&&p.upload&&p.upload.addEventListener("progress",t.onUploadProgress),t.cancelToken&&t.cancelToken.promise.then((function(t){p&&(p.abort(),l(t),p=null)})),void 0===u&&(u=null),p.send(u)}))}},function(t,e,n){"use strict";var r=n(36);t.exports=function(t,e,n,o,s){var i=new Error(t);return r(i,e,n,o,s)}},function(t,e,n){"use strict";var r=n(0);t.exports=function(t,e){e=e||{};var n={};return r.forEach(["url","method","params","data"],(function(t){void 0!==e[t]&&(n[t]=e[t])})),r.forEach(["headers","auth","proxy"],(function(o){r.isObject(e[o])?n[o]=r.deepMerge(t[o],e[o]):void 0!==e[o]?n[o]=e[o]:r.isObject(t[o])?n[o]=r.deepMerge(t[o]):void 0!==t[o]&&(n[o]=t[o])})),r.forEach(["baseURL","transformRequest","transformResponse","paramsSerializer","timeout","withCredentials","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","maxContentLength","validateStatus","maxRedirects","httpAgent","httpsAgent","cancelToken","socketPath"],(function(r){void 0!==e[r]?n[r]=e[r]:void 0!==t[r]&&(n[r]=t[r])})),n}},function(t,e,n){"use strict";function r(t){this.message=t}r.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},r.prototype.__CANCEL__=!0,t.exports=r},function(t,e){function expect(t){let e=!1;const n=t=>"object"==typeof t?JSON.stringify(t):t;function r(r,o,s){if(e?r:!r)throw new Error(s||`expected value${e?" not":""} to be ${o} but was ${n(t)}`)}return{get not(){return e=!e,this},toBe:(e,o)=>r(t===e,`${n(e)}`,o),toEqual:(e,o)=>r(function t(e,n){return typeof e==typeof n&&("object"==typeof e&&"object"==typeof n?Object.keys(e).length===Object.keys(n).length&&Object.keys(e).every(r=>t(e[r],n[r])):e===n)}(t,e),`equal to ${n(e)}`,o),toBeInstanceOf:(e,n)=>r(t&&t instanceof e,`an instance of ${e.name}`,n),toBeDefined:e=>r(void 0!==t,"defined",e),toBeNull:e=>r(null===t,"null",e),toBeNumber:e=>r("number"==typeof t,"a number",e),toBeInteger:e=>r(Number.isInteger(t),"an integer",e),toBeLessThan:(e,n)=>r(t<e&&"number"==typeof t&&"number"==typeof e,`less than ${e}`,n),toBeLessThanOrEqualTo:(e,n)=>r(t<=e&&"number"==typeof t&&"number"==typeof e,`less than or equal to ${e}`,n),toBeGreaterThan:(e,n)=>r(t>e&&"number"==typeof t&&"number"==typeof e,`greater than ${e}`,n),toBeGreaterThanOrEqualTo:(e,n)=>r(t>=e&&"number"==typeof t&&"number"==typeof e,`greater than or equal to ${e}`,n),toBeBoolean:e=>r("boolean"==typeof t,"a boolean",e),toBeString:e=>r("string"==typeof t,"a string",e),toBeObject:e=>r(t&&"object"==typeof t,"an object",e),toBeArray:e=>r(Array.isArray(t),"an array",e),toBeClass:e=>r("function"==typeof t&&t.toString().startsWith("class"),"a class",e),toBeFunction:e=>r("function"==typeof t&&!t.toString().startsWith("class"),"a function",e)}}expect.originTestnet="f02739791f7d54bfed43452faef4c994f87d93d33cafa4d246345358d4f96460_o1",expect.locationTestnet="f02739791f7d54bfed43452faef4c994f87d93d33cafa4d246345358d4f96460_o1",expect.ownerTestnet="020b48771735aac0b1d5362a5341f7f9ff9df9deac0aec709c9314ba5460254189",expect.originMainnet="4fce929af95eaae77fbb75520c5c6cc37a60b8809a8e30794aa54de85151cc5a_o1",expect.locationMainnet="4fce929af95eaae77fbb75520c5c6cc37a60b8809a8e30794aa54de85151cc5a_o1",expect.ownerMainnet="02ed21e46d53ca50b04dbb44d27db3e773602276178425ab6ed69743f82d7a3468",t.exports=expect},function(t,e,n){"use strict";e.byteLength=function(t){var e=l(t),n=e[0],r=e[1];return 3*(n+r)/4-r},e.toByteArray=function(t){var e,n,r=l(t),i=r[0],a=r[1],c=new s(function(t,e,n){return 3*(e+n)/4-n}(0,i,a)),u=0,h=a>0?i-4:i;for(n=0;n<h;n+=4)e=o[t.charCodeAt(n)]<<18|o[t.charCodeAt(n+1)]<<12|o[t.charCodeAt(n+2)]<<6|o[t.charCodeAt(n+3)],c[u++]=e>>16&255,c[u++]=e>>8&255,c[u++]=255&e;2===a&&(e=o[t.charCodeAt(n)]<<2|o[t.charCodeAt(n+1)]>>4,c[u++]=255&e);1===a&&(e=o[t.charCodeAt(n)]<<10|o[t.charCodeAt(n+1)]<<4|o[t.charCodeAt(n+2)]>>2,c[u++]=e>>8&255,c[u++]=255&e);return c},e.fromByteArray=function(t){for(var e,n=t.length,o=n%3,s=[],i=0,a=n-o;i<a;i+=16383)s.push(u(t,i,i+16383>a?a:i+16383));1===o?(e=t[n-1],s.push(r[e>>2]+r[e<<4&63]+"==")):2===o&&(e=(t[n-2]<<8)+t[n-1],s.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"="));return s.join("")};for(var r=[],o=[],s="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,c=i.length;a<c;++a)r[a]=i[a],o[i.charCodeAt(a)]=a;function l(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=t.indexOf("=");return-1===n&&(n=e),[n,n===e?0:4-n%4]}function u(t,e,n){for(var o,s,i=[],a=e;a<n;a+=3)o=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),i.push(r[(s=o)>>18&63]+r[s>>12&63]+r[s>>6&63]+r[63&s]);return i.join("")}o["-".charCodeAt(0)]=62,o["_".charCodeAt(0)]=63},function(t,e){e.read=function(t,e,n,r,o){var s,i,a=8*o-r-1,c=(1<<a)-1,l=c>>1,u=-7,h=n?o-1:0,p=n?-1:1,f=t[e+h];for(h+=p,s=f&(1<<-u)-1,f>>=-u,u+=a;u>0;s=256*s+t[e+h],h+=p,u-=8);for(i=s&(1<<-u)-1,s>>=-u,u+=r;u>0;i=256*i+t[e+h],h+=p,u-=8);if(0===s)s=1-l;else{if(s===c)return i?NaN:1/0*(f?-1:1);i+=Math.pow(2,r),s-=l}return(f?-1:1)*i*Math.pow(2,s-r)},e.write=function(t,e,n,r,o,s){var i,a,c,l=8*s-o-1,u=(1<<l)-1,h=u>>1,p=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,f=r?0:s-1,d=r?1:-1,g=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,i=u):(i=Math.floor(Math.log(e)/Math.LN2),e*(c=Math.pow(2,-i))<1&&(i--,c*=2),(e+=i+h>=1?p/c:p*Math.pow(2,1-h))*c>=2&&(i++,c/=2),i+h>=u?(a=0,i=u):i+h>=1?(a=(e*c-1)*Math.pow(2,o),i+=h):(a=e*Math.pow(2,h-1)*Math.pow(2,o),i=0));o>=8;t[n+f]=255&a,f+=d,a/=256,o-=8);for(i=i<<o|a,l+=o;l>0;t[n+f]=255&i,f+=d,i/=256,l-=8);t[n+f-d]|=128*g}},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e,n){t.exports=function(){"use strict";function t(t,e){const n=`please report internal shim error: ${t}`;throw console.error(n),e&&(console.error(`${e}`),console.error(`${e.aabc}`)),n}function e(e,n){e||t(n)}function r(t){let e=`'use strict'; (${t})`;return e=e.replace(/\(0,\s*_[0-9a-fA-F]{3}\u200D\.e\)/g,"(0, eval)"),e=e.replace(/_[0-9a-fA-F]{3}\u200D\.g\./g,""),e=e.replace(/cov_[^+]+\+\+[;,]/g,""),e}function o(t,e){const{callAndWrapError:n}=t,{initRootRealm:r,initCompartment:o,getRealmGlobal:s,realmEvaluate:i}=e,{create:a,defineProperties:c}=Object;class l{constructor(){throw new TypeError("Realm is not a constructor")}static makeRootRealm(e={}){const o=a(l.prototype);return n(r,[t,o,e]),o}static makeCompartment(e={}){const r=a(l.prototype);return n(o,[t,r,e]),r}get global(){return n(s,[this])}evaluate(t,e,r={}){return n(i,[this,t,e,r])}}return c(l,{toString:{value:()=>"function Realm() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),c(l.prototype,{toString:{value:()=>"[object Realm]",writable:!1,enumerable:!1,configurable:!0}}),l}const s=r(o),i=r((function(){const{getPrototypeOf:t}=Object,{apply:e}=Reflect,n=t=>(n,...r)=>e(t,n,r),r=n(Map.prototype.get),o=n(Set.prototype.has),s=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]),i=new Set([EvalError.prototype,RangeError.prototype,ReferenceError.prototype,SyntaxError.prototype,TypeError.prototype,URIError.prototype,Error.prototype]);return function(n,a){try{return e(n,void 0,a)}catch(e){if(Object(e)!==e)throw e;if(o(i,t(e)))throw e;let n,a,c;try{n=`${e.name}`,a=`${e.message}`,c=`${e.aabc||a}`}catch(t){throw new Error("unknown error")}const l=r(s,n)||Error;try{throw new l(a)}catch(t){throw t.aabc=c,t}}}})),{assign:a,create:c,freeze:l,defineProperties:u,getOwnPropertyDescriptor:h,getOwnPropertyDescriptors:p,getOwnPropertyNames:f,getPrototypeOf:d,setPrototypeOf:g}=Object,{apply:y,ownKeys:m}=Reflect,w=t=>(e,...n)=>y(t,e,n),b=w(Object.prototype.hasOwnProperty),E=w(Array.prototype.filter),v=w(Array.prototype.pop),S=w(Array.prototype.join),x=w(Array.prototype.concat),j=w(RegExp.prototype.test),A=w(String.prototype.includes),T=["Infinity","NaN","undefined"],O=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Array","ArrayBuffer","Boolean","DataView","EvalError","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Object","RangeError","ReferenceError","Set","String","Symbol","SyntaxError","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakSet","JSON","Math","Reflect","escape","unescape"],k=["Date","Error","Promise","Proxy","RegExp","Intl"];function P(){const{defineProperty:t,defineProperties:e,getOwnPropertyDescriptor:n,getPrototypeOf:r,prototype:o}=Object;try{(0,o.__lookupGetter__)("x")}catch(t){return}function s(t){if(null==t)throw new TypeError("can't convert undefined or null to object");return Object(t)}function i(t){return"symbol"==typeof t?t:`${t}`}function a(t,e){if("function"!=typeof t)throw TypeError(`invalid ${e} usage`);return t}e(o,{__defineGetter__:{value:function(e,n){const r=s(this);t(r,e,{get:a(n,"getter"),enumerable:!0,configurable:!0})}},__defineSetter__:{value:function(e,n){const r=s(this);t(r,e,{set:a(n,"setter"),enumerable:!0,configurable:!0})}},__lookupGetter__:{value:function(t){let e,o=s(this);for(t=i(t);o&&!(e=n(o,t));)o=r(o);return e&&e.get}},__lookupSetter__:{value:function(t){let e,o=s(this);for(t=i(t);o&&!(e=n(o,t));)o=r(o);return e&&e.set}}})}function I(){const{defineProperties:t,getPrototypeOf:e,setPrototypeOf:n}=Object;function r(r,o){let s;try{s=(0,eval)(o)}catch(t){if(t instanceof SyntaxError)return;throw t}const i=e(s),a=function(){throw new TypeError("Not available")};t(a,{name:{value:r}}),t(i,{constructor:{value:a}}),t(a,{prototype:{value:i}}),a!==Function.prototype.constructor&&n(a,Function.prototype.constructor)}r("Function","(function(){})"),r("GeneratorFunction","(function*(){})"),r("AsyncFunction","(async function(){})"),r("AsyncGeneratorFunction","(async function*(){})")}const _=()=>{const t=function(){if("undefined"==typeof document)return;const t=document.createElement("iframe");return t.style.display="none",document.body.appendChild(t),t.contentWindow.eval("'use strict'; this")}(),e=function(){if(new Function("try {return this===global}catch(e){return false}")())return n(23).runInNewContext("(0, eval)(\"'use strict'; this\")")}();if(!t&&!e||t&&e)throw new Error("unexpected platform, unable to create Realm");return t||e};function $(t,n=[]){const r=function(t){const n={};function r(r,o,s,i){for(const a of r){const r=h(t,a);r&&(e("value"in r,`unexpected accessor on global property: ${a}`),n[a]={value:r.value,writable:o,enumerable:s,configurable:i})}}return r(T,!1,!1,!1),r(O,!1,!1,!1),r(k,!0,!1,!0),n}(t),o=t.eval,s=t.Function,a=o(i)();return l({unsafeGlobal:t,sharedGlobalDescs:r,unsafeEval:o,unsafeFunction:s,callAndWrapError:a,allShims:n})}const R=r(P),C=r(I),N=/^[a-zA-Z_$][\w$]*$/,F=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"]);function U(t,e={}){const n=f(t);return E(n,n=>{if(n in e)return!1;if("eval"===n||F.has(n)||!j(N,n))return!1;const r=h(t,n);return(!1===r.configurable&&!1===r.writable&&b(r,"value"))})}const D=r((function(t,e,n={},r=!1){const{unsafeGlobal:o,unsafeEval:s}=t,{freeze:i,getOwnPropertyDescriptor:a}=Object,{get:c,set:l}=Reflect;return{__proto__:new Proxy(i({}),{get(t,e){throw new TypeError(`unexpected scope handler trap called: ${String(e)}`)}}),useUnsafeEvaluator:!1,get(t,r){if("symbol"!=typeof r)return"eval"===r&&!0===this.useUnsafeEvaluator?(this.useUnsafeEvaluator=!1,s):r in n?c(n,r,e):c(e,r)},set:(t,r,o)=>r in n?"value"in a(n,r)?l(n,r,o):l(n,r,o,e):l(e,r,o),has:(t,s)=>!!r||"eval"===s||s in n||s in e||s in o,getPrototypeOf:()=>null}})),M=r((function(t,e){const{callAndWrapError:n}=t,{defineProperties:r}=Object,o={eval(){return n(e,arguments)}}.eval;return r(o,{toString:{value:()=>"function eval() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),o})),B=r((function(t,e){const{callAndWrapError:n,unsafeFunction:r}=t,{defineProperties:o}=Object,s=function(){return n(e,arguments)};return o(s,{prototype:{value:r.prototype},toString:{value:()=>"function Function() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),s})),L=r((function(t,e){const{create:n,getOwnPropertyDescriptors:r}=Object,{apply:o}=Reflect;var s;return t={src:`${(t=(s=Array.prototype.reduce,(t,...e)=>o(s,t,e))(e,(t,e)=>e.rewrite?e.rewrite(t):t,t={src:`${t.src}`,endowments:n(null,r(t.endowments))})).src}`,endowments:n(null,r(t.endowments))}})),G=new RegExp("(?:\x3c!--|--\x3e)"),H=/\bimport\s*(?:\(|\/[/*])/,W=/\beval\s*(?:\(|\/[/*])/;function q(t){!function(t){const e=t.search(G);if(-1!==e){const n=t.slice(0,e).split("\n").length;throw new SyntaxError(`possible html comment syntax rejected around line ${n}`)}}(t),function(t){const e=t.search(H);if(-1!==e){const n=t.slice(0,e).split("\n").length;throw new SyntaxError(`possible import expression rejected around line ${n}`)}}(t),function(t){const e=t.search(W);if(-1!==e){const n=t.slice(0,e).split("\n").length;throw new SyntaxError(`possible direct eval expression rejected around line ${n}`)}}(t)}const J={rewrite:t=>(q(t.src),t)};function z(t,e,n=!0){const{unsafeFunction:r}=t;return r(`\n    with (arguments[0]) {\n      ${function(t){return 0===t.length?"":`const {${S(t,",")}} = this;`}(e)}\n      return function() {\n        ${n?"'use strict';":""}\n        return eval(arguments[0]);\n      };\n    }\n  `)}const Y=new WeakMap;function K(t){return e(Object(t)===t,"bad object, not a Realm instance"),e(Y.has(t),"Realm instance has no record"),Y.get(t)}function V(t,n){e(Object(t)===t,"bad object, not a Realm instance"),e(!Y.has(t),"Realm instance already has a record"),Y.set(t,n)}function X(n,r,o){const{sharedGlobalDescs:s,unsafeGlobal:i}=n,a=c(i.Object.prototype,s),h=function(e,n,r,o){const{unsafeEval:s}=e,i=s(L);return function(a={},c={}){const l=c.transforms||[],u=x(l,r||[],[J]);return function(r){let c={src:r,endowments:a};c=i(c,u);const l=U(n,c.endowments),h=U(c.endowments),p=x(l,h),f=r.startsWith("with($globals){'use strict';"),d=z(e,p,!f),g=s(D)(e,n,c.endowments,o),m=Proxy.revocable({},g),w=m.proxy,b=y(d,n,[w]);let E;g.useUnsafeEvaluator=!0;try{return y(b,n,[c.src])}catch(t){throw E=t,t}finally{g.useUnsafeEvaluator&&(m.revoke(),t("handler did not revoke useUnsafeEvaluator",E))}}}}(n,a,r,o),p=h(),f=function(t,n){const{unsafeEval:r,unsafeFunction:o}=t,s=r(M)(t,n);return e(d(s).constructor!==Function,"hide Function"),e(d(s).constructor!==o,"hide unsafeFunction"),s}(n,p),g=function(t,n){const{unsafeGlobal:r,unsafeEval:o,unsafeFunction:s}=t,i=o(B)(t,(function(...t){const e=`${v(t)||""}`;let o=`${S(t,",")}`;if(!j(/^[\w\s,]*$/,o))throw new SyntaxError("shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names");if(new s(e),A(o,")"))throw new r.SyntaxError("shim limitation: Function arg string contains parenthesis");return o.length>0&&(o+="\n/*``*/"),n(`(function(${o}){\n${e}\n})`)}));return e(d(i).constructor!==Function,"hide Function"),e(d(i).constructor!==s,"hide unsafeFunction"),i}(n,p),m=function(t){return(e,n,r={})=>t(n,r)(e)}(h);return function(t,e,n){u(t,{eval:{value:e,writable:!0,configurable:!0},Function:{value:n,writable:!0,configurable:!0}})}(a,f,g),l({safeGlobal:a,safeEval:f,safeEvalWhichTakesEndowments:m,safeFunction:g})}const Q={initRootRealm:function(t,e,n){const{shims:r,transforms:o,sloppyGlobals:i}=n,a=x(t.allShims,r),c=function(t){const e=$(_(),t),{unsafeEval:n}=e;return n(R)(),n(C)(),e}(a),{unsafeEval:l}=c,u=l(s)(c,Q);c.sharedGlobalDescs.Realm={value:u,writable:!0,configurable:!0};const h=X(c,o,i),{safeEvalWhichTakesEndowments:p}=h;for(const t of a)p(t);V(e,h)},initCompartment:function(t,e,n={}){const{transforms:r,sloppyGlobals:o}=n;V(e,X(t,r,o))},getRealmGlobal:function(t){const{safeGlobal:e}=K(t);return e},realmEvaluate:function(t,e,n={},r={}){const{safeEvalWhichTakesEndowments:o}=K(t);return o(e,n,r)}},Z=o(function(){const t=(0,eval)("'use strict'; this");return P(),I(),$(t)}(),Q);function tt(t,e={}){const{freeze:n,getOwnPropertyDescriptors:r,getPrototypeOf:o}=Object,{ownKeys:s}=Reflect;let{fringeSet:i}=e;if(i){if("function"!=typeof i.add||"function"!=typeof i.has)throw new TypeError("options.fringeSet must have add() and has() methods");if(t)for(const e of t)i.add(e)}else i=new WeakSet(t);const a=e&&e.naivePrepareObject;return function(t){const e=new Set,c=new Map,l=new WeakMap;function u(t,n){if(Object(t)!==t)return;const r=typeof t;if("object"!==r&&"function"!==r)throw new TypeError(`Unexpected typeof: ${r}`);i.has(t)||e.has(t)||(e.add(t),l.set(t,n))}function h(t){a&&a(t),n(t);const e=o(t),i=r(t),h=l.get(t)||"unknown";null===e||c.has(e)||(c.set(e,h),l.set(e,`${h}.__proto__`)),s(i).forEach(t=>{const e=`${h}.${String(t)}`,n=i[t];"value"in n?u(n.value,`${e}`):(u(n.get,`${e}(get)`),u(n.set,`${e}(set)`))})}return u(t),e.forEach(h),c.forEach((t,n)=>{if(!e.has(n)&&!i.has(n)){let e;try{e=`prototype ${n} of ${t} is not already in the fringeSet`}catch(r){e="a prototype of something is not already in the fringeset (and .toString failed)";try{console.log(e),console.log("the prototype:",n),console.log("of something:",t)}catch(t){}}throw new TypeError(e)}}),e.forEach(i.add,i),t}}function et(){const t=Date,e=function(...e){return void 0===new.target?"Invalid Date":e.length>0?Reflect.construct(t,e,new.target):Reflect.construct(t,[NaN],new.target)};Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)),t.prototype.constructor=e,e.now=()=>NaN,Date=e}function nt(){Math.random=()=>{throw Error("disabled")}}function rt(){"undefined"!=typeof Intl&&(Intl.DateTimeFormat=()=>{throw Error("disabled")},Intl.NumberFormat=()=>{throw Error("disabled")},Intl.getCanonicalLocales=()=>{throw Error("disabled")}),Object.prototype.toLocaleString=()=>{throw new Error("toLocaleString suppressed")}}function ot(){if(!Object.isExtensible(Error))throw Error("huh Error is not extensible");if(delete Error.captureStackTrace,"captureStackTrace"in Error)throw Error("hey we could not remove Error.captureStackTrace")}function st(){if(delete RegExp.prototype.compile,"compile"in RegExp.prototype)throw Error("hey we could not remove RegExp.prototype.compile");const t=RegExp;if(RegExp=function(...e){return Reflect.construct(t,e,new.target)},RegExp.prototype=t.prototype,t.prototype.constructor=RegExp,"$1"in RegExp)throw Error("hey we could not remove RegExp.$1")}function it(t,e){const{getOwnPropertyDescriptor:n,getOwnPropertyNames:r,keys:o}=Object,s=new WeakMap,i=Object.getPrototypeOf,a=(c=Object.prototype.hasOwnProperty,(t,...e)=>Reflect.apply(c,t,e));var c;const l=new WeakMap;function u(t,e){const r=[!0,!1,"*","maybeAccessor"];!function t(e,s){if(e===Object(e))if("object"==typeof s){if(l.has(e))throw new Error("primordial reachable through multiple paths");l.set(e,s),o(s).forEach(r=>{const o=n(e,r);o&&t(o.value,s[r])})}else if(r.indexOf(s)<0)throw new Error(`syntax error in whitelist; unexpected value: ${s}`)}(t,e)}u(t,e.namedIntrinsics),u(getAnonIntrinsics(t),e.anonIntrinsics),function t(e,o,c){if(e!==Object(e))return;if(s.get(e))return;const u=i(e);if(null!==u&&!l.has(u))throw new Error(`unexpected intrinsic ${o}.__proto__`);s.set(e,!0),r(e).forEach(r=>{const s=o+(o?".":"")+r,c=function(t,e){let n=l.get(t);if(n){if(a(n,e))return n[e];if(a(n,`ESCAPE${e}`))return n[`ESCAPE${e}`]}for(;;){if(null===(t=i(t)))return!1;if(n=l.get(t),n&&a(n,e)){const t=n[e];return"*"===t&&t}}}(e,r);if(c){const o=n(e,r);a(o,"value")?t(o.value,s):"maybeAccessor"!==c?delete e[r]:(t(o.get,`${s}<getter>`),t(o.set,`${s}<setter>`))}else delete e[r]})}(t,"")}function at(t){const e=Object.getOwnPropertyDescriptor,n=Object.getPrototypeOf;function*r(){}const o=n(r);async function s(){}const i=n(s);function a(e,r,o){const s=t.Symbol&&t.Symbol.iterator||"@@iterator";if(r[s]){const t=r[s](),i=n(t);e[o]=i;const a=n(i);if(a!==Object.prototype)if(e.IteratorPrototype){if(e.IteratorPrototype!==a)throw new Error(`unexpected %${o}%.__proto__`)}else{if(n(a)!==Object.prototype)throw new Error("%IteratorPrototype%.__proto__ was not Object.prototype");e.IteratorPrototype=a}}}return[["Object.prototype",Object.prototype,{}],["Function.prototype",Function.prototype,function(){}],["Array.prototype",Array.prototype,[]],["RegExp.prototype",RegExp.prototype,/x/],["Boolean.prototype",Boolean.prototype,!0],["Number.prototype",Number.prototype,1],["String.prototype",String.prototype,"x"],["%Generator%",o,r],["%AsyncFunction%",i,s]].forEach(t=>{t[0];const e=t[1];let r=t[2];if(void 0!==r&&(r=Object(r),e!==r&&e!==n(r)))throw new Error(`Unexpected undeniable: ${e}`)}),function(){const r={};if(r.ThrowTypeError=e(arguments,"callee").get,a(r,[],"ArrayIteratorPrototype"),a(r,"","StringIteratorPrototype"),"function"==typeof Map&&a(r,new Map,"MapIteratorPrototype"),"function"==typeof Set&&a(r,new Set,"SetIteratorPrototype"),n(o)!==Function.prototype)throw new Error("Generator.__proto__ was not Function.prototype");const s=o.constructor;if(n(s)!==Function.prototype.constructor)throw new Error("GeneratorFunction.__proto__ was not Function.prototype.constructor");r.GeneratorFunction=s;const c=n(o.prototype);if(c!==r.IteratorPrototype)throw new Error("Unexpected Generator.prototype.__proto__");if(n(i)!==Function.prototype)throw new Error("AsyncFunctionPrototype.__proto__ was not Function.prototype");const l=i.constructor;if(n(l)!==Function.prototype.constructor)throw new Error("AsyncFunction.__proto__ was not Function.prototype.constructor");return r.AsyncFunction=l,function(){if(!t.Float32Array)return;const e=n(t.Float32Array);if(e!==Function.prototype){if(n(e)!==Function.prototype)throw new Error("TypedArray.__proto__ was not Function.prototype");r.TypedArray=e}}(),Object.keys(r).forEach(t=>{if(void 0===r[t])throw new Error(`Malformed intrinsic: ${t}`)}),r}()}function ct(t,e){const{defineProperty:n,getOwnPropertyDescriptor:r,ownKeys:o}=Reflect,s={},i=o(e.namedIntrinsics);for(const e of i){const o=r(t,e);if(o){if("get"in o||"set"in o)throw new TypeError(`unexpected accessor on global property: ${e}`);n(s,e,o)}}return s}function lt(t,e){return{global:t,anonIntrinsics:e}}function ut(t,e){return{namedIntrinsics:t,anonIntrinsics:e}}const ht=!0,pt=!0;let ft;var dt={anonIntrinsics:{ThrowTypeError:{},IteratorPrototype:{next:"*",constructor:!1},ArrayIteratorPrototype:{},StringIteratorPrototype:{},MapIteratorPrototype:{},SetIteratorPrototype:{},AsyncIteratorPrototype:{},GeneratorFunction:{length:"*",prototype:{prototype:{next:"*",return:"*",throw:"*",constructor:"*"}}},AsyncGeneratorFunction:{length:"*",prototype:{prototype:{next:"*",return:"*",throw:"*",constructor:"*"}}},AsyncFunction:{length:"*",prototype:"*"},TypedArray:ft={length:"*",name:"*",from:ht,of:ht,BYTES_PER_ELEMENT:"*",prototype:{buffer:"maybeAccessor",byteLength:"maybeAccessor",byteOffset:"maybeAccessor",copyWithin:"*",entries:"*",every:"*",fill:"*",filter:"*",find:"*",findIndex:"*",forEach:"*",includes:"*",indexOf:"*",join:"*",keys:"*",lastIndexOf:"*",length:"maybeAccessor",map:"*",reduce:"*",reduceRight:"*",reverse:"*",set:"*",slice:"*",some:"*",sort:"*",subarray:"*",values:"*",BYTES_PER_ELEMENT:"*"}}},namedIntrinsics:{Infinity:pt,NaN:pt,undefined:pt,eval:pt,isFinite:ht,isNaN:ht,parseFloat:ht,parseInt:ht,decodeURI:ht,decodeURIComponent:ht,encodeURI:ht,encodeURIComponent:ht,Object:{assign:ht,create:ht,defineProperties:ht,defineProperty:ht,entries:ht,freeze:pt,getOwnPropertyDescriptor:ht,getOwnPropertyDescriptors:ht,getOwnPropertyNames:ht,getOwnPropertySymbols:ht,getPrototypeOf:ht,is:pt,isExtensible:ht,isFrozen:ht,isSealed:ht,keys:ht,preventExtensions:pt,seal:pt,setPrototypeOf:ht,values:ht,prototype:{ESCAPE__proto__:"maybeAccessor",__defineGetter__:ht,__defineSetter__:ht,__lookupGetter__:ht,__lookupSetter__:ht,constructor:"*",hasOwnProperty:ht,isPrototypeOf:ht,propertyIsEnumerable:ht,toLocaleString:"*",toString:"*",valueOf:"*",[Symbol.iterator]:"*",[Symbol.toPrimitive]:"*",[Symbol.toStringTag]:"*",[Symbol.unscopables]:"*"}},Function:{length:ht,prototype:{apply:ht,bind:ht,call:ht,[Symbol.hasInstance]:"*",length:"*",name:"*",prototype:"*",arity:"*",[Symbol.species]:"maybeAccessor"}},Boolean:{prototype:ht},Symbol:{asyncIterator:ht,for:ht,hasInstance:ht,isConcatSpreadable:ht,iterator:ht,keyFor:ht,match:ht,matchAll:ht,replace:ht,search:ht,species:ht,split:ht,toPrimitive:ht,toStringTag:ht,unscopables:ht,prototype:ht},Error:{prototype:{name:"*",message:"*"}},EvalError:{prototype:ht},RangeError:{prototype:ht},ReferenceError:{prototype:ht},SyntaxError:{prototype:ht},TypeError:{prototype:ht},URIError:{prototype:ht},Number:{EPSILON:ht,isFinite:pt,isInteger:ht,isNaN:pt,isSafeInteger:pt,MAX_SAFE_INTEGER:pt,MAX_VALUE:ht,MIN_SAFE_INTEGER:pt,MIN_VALUE:ht,NaN:ht,NEGATIVE_INFINITY:ht,parseFloat:ht,parseInt:ht,POSITIVE_INFINITY:ht,prototype:{toExponential:ht,toFixed:ht,toPrecision:ht}},Math:{E:pt,LN10:pt,LN2:pt,LOG10E:ht,LOG2E:ht,PI:pt,SQRT1_2:ht,SQRT2:ht,abs:pt,acos:ht,acosh:ht,asin:ht,asinh:ht,atan:ht,atanh:ht,atan2:ht,cbrt:ht,ceil:pt,clz32:ht,cos:ht,cosh:ht,exp:ht,expm1:ht,floor:pt,fround:ht,hypot:ht,imul:ht,log:pt,log1p:ht,log10:pt,log2:pt,max:pt,min:pt,pow:pt,random:ht,round:pt,sign:ht,sin:ht,sinh:ht,sqrt:pt,tan:ht,tanh:ht,trunc:pt},Date:{now:ht,parse:ht,UTC:ht,prototype:{getDate:ht,getDay:ht,getFullYear:ht,getHours:ht,getMilliseconds:ht,getMinutes:ht,getMonth:ht,getSeconds:ht,getTime:ht,getTimezoneOffset:ht,getUTCDate:ht,getUTCDay:ht,getUTCFullYear:ht,getUTCHours:ht,getUTCMilliseconds:ht,getUTCMinutes:ht,getUTCMonth:ht,getUTCSeconds:ht,setDate:ht,setFullYear:ht,setHours:ht,setMilliseconds:ht,setMinutes:ht,setMonth:ht,setSeconds:ht,setTime:ht,setUTCDate:ht,setUTCFullYear:ht,setUTCHours:ht,setUTCMilliseconds:ht,setUTCMinutes:ht,setUTCMonth:ht,setUTCSeconds:ht,toDateString:ht,toISOString:ht,toJSON:ht,toLocaleDateString:ht,toLocaleString:ht,toLocaleTimeString:ht,toTimeString:ht,toUTCString:ht,getYear:ht,setYear:ht,toGMTString:ht}},String:{fromCharCode:pt,fromCodePoint:ht,raw:pt,prototype:{charAt:ht,charCodeAt:ht,codePointAt:ht,concat:ht,endsWith:pt,includes:ht,indexOf:pt,lastIndexOf:pt,localeCompare:ht,match:ht,normalize:ht,padEnd:ht,padStart:ht,repeat:ht,replace:ht,search:ht,slice:pt,split:ht,startsWith:pt,substring:ht,toLocaleLowerCase:ht,toLocaleUpperCase:ht,toLowerCase:ht,toUpperCase:ht,trim:ht,substr:ht,anchor:ht,big:ht,blink:ht,bold:ht,fixed:ht,fontcolor:ht,fontsize:ht,italics:ht,link:ht,small:ht,strike:ht,sub:ht,sup:ht,trimLeft:ht,trimRight:ht,length:"*"}},RegExp:{prototype:{exec:ht,flags:"maybeAccessor",global:"maybeAccessor",ignoreCase:"maybeAccessor",[Symbol.match]:"*",multiline:"maybeAccessor",[Symbol.replace]:"*",[Symbol.search]:"*",source:"maybeAccessor",[Symbol.split]:"*",sticky:"maybeAccessor",test:ht,unicode:"maybeAccessor",dotAll:"maybeAccessor",compile:!1,lastIndex:"*",options:"*"}},Array:{from:pt,isArray:ht,of:pt,prototype:{concat:ht,copyWithin:ht,entries:ht,every:ht,fill:ht,filter:pt,find:ht,findIndex:ht,forEach:pt,includes:ht,indexOf:pt,join:ht,keys:ht,lastIndexOf:pt,map:pt,pop:pt,push:pt,reduce:pt,reduceRight:pt,reverse:ht,shift:pt,slice:pt,some:ht,sort:ht,splice:ht,unshift:pt,values:ht,length:"*"}},Int8Array:ft,Uint8Array:ft,Uint8ClampedArray:ft,Int16Array:ft,Uint16Array:ft,Int32Array:ft,Uint32Array:ft,Float32Array:ft,Float64Array:ft,Map:{prototype:{clear:pt,delete:pt,entries:pt,forEach:pt,get:pt,has:pt,keys:pt,set:pt,size:"maybeAccessor",values:pt}},Set:{prototype:{add:pt,clear:pt,delete:pt,entries:pt,forEach:pt,has:pt,keys:pt,size:"maybeAccessor",values:pt}},WeakMap:{prototype:{delete:pt,get:pt,has:pt,set:pt}},WeakSet:{prototype:{add:pt,delete:pt,has:pt}},ArrayBuffer:{isView:ht,length:ht,name:ht,prototype:{byteLength:"maybeAccessor",slice:ht}},DataView:{length:ht,name:ht,BYTES_PER_ELEMENT:"*",prototype:{buffer:"maybeAccessor",byteOffset:"maybeAccessor",byteLength:"maybeAccessor",getFloat32:ht,getFloat64:ht,getInt8:ht,getInt16:ht,getInt32:ht,getUint8:ht,getUint16:ht,getUint32:ht,setFloat32:ht,setFloat64:ht,setInt8:ht,setInt16:ht,setInt32:ht,setUint8:ht,setUint16:ht,setUint32:ht}},JSON:{parse:pt,stringify:pt},Promise:{all:pt,race:pt,reject:pt,resolve:pt,makeHandled:ht,prototype:{catch:ht,then:pt,finally:ht,delete:ht,get:ht,put:ht,post:ht,invoke:ht,fapply:ht,fcall:ht,del:ht,send:ht,end:ht}},Q:{all:ht,race:ht,reject:ht,resolve:ht,join:ht,isPassByCopy:ht,passByCopy:ht,makeRemote:ht,makeFar:ht,shorten:ht,isPromise:ht,async:ht,rejected:ht,promise:ht,delay:ht,memoize:ht,defer:ht},Reflect:{apply:ht,construct:ht,defineProperty:ht,deleteProperty:ht,get:ht,getOwnPropertyDescriptor:ht,getPrototypeOf:ht,has:ht,isExtensible:ht,ownKeys:ht,preventExtensions:ht,set:ht,setPrototypeOf:ht},Proxy:{revocable:ht},escape:ht,unescape:ht,StringMap:{prototype:{}},Realm:{makeRootRealm:ht,makeCompartment:ht,prototype:{global:"maybeAccessor",evaluate:ht}},SES:{confine:ht,confineExpr:ht,harden:ht},Nat:pt,def:pt}};function gt(t){const e=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]),n={};return["log","info","warn","error","group","groupEnd","trace","time","timeLog","timeEnd"].forEach(r=>{if(r in t){const o=t[r];n[r]=function(...t){!function(t,...n){try{t(...n)}catch(t){if(Object(t)!==t)throw t;let n,r,o;try{n=`${t.name}`,r=`${t.message}`,o=`${t.aabc||r}`}catch(t){throw new Error("unknown error")}const s=e.get(n)||Error;try{throw new s(r)}catch(t){throw t.aabc=o,t}}}(o,...t)}}}),n}function yt(t,e){return function(n){const r=new Map;return function(o){const s=`${o}`;return r.has(s)||r.set(s,e(function(r){if(!Object.prototype.hasOwnProperty.call(n,r))throw new Error(`Cannot find module '${r}'`);const o=n[r];if("@agoric/harden"===r)return e;if("function"==typeof o)return t.evaluate(`(${o})`);const s=`(${o.attenuatorSource})`;return t.evaluate(s)(o)}(s))),r.get(s)}}}var mt={namedIntrinsics:{Object:{prototype:"*"},Array:{prototype:"*"},Function:{prototype:{constructor:!0,bind:!0,name:!0,toString:!0}},Error:{prototype:{constructor:!0,message:!0,name:!0,toString:!0}},TypeError:{prototype:{constructor:!0,name:!0}},Promise:{prototype:{constructor:!0}}},anonIntrinsics:{TypedArray:{prototype:"*"},GeneratorFunction:{prototype:{constructor:!0,name:!0,toString:!0}},AsyncFunction:{prototype:{constructor:!0,name:!0,toString:!0}},AsyncGeneratorFunction:{prototype:{constructor:!0,name:!0,toString:!0}},IteratorPrototype:"*"}};function wt(t,e){const{defineProperties:n,getOwnPropertyDescriptor:r,getOwnPropertyDescriptors:o,prototype:{hasOwnProperty:s}}=Object,{ownKeys:i}=Reflect;function a(t,e,r){if("value"in r&&r.configurable){const{value:i}=r;function o(){return i}o.value=i,n(t,{[e]:{get:o,set:function(o){if(t===this)throw new TypeError(`Cannot assign to read only property '${e}' of object '${t}'`);s.call(this,e)?this[e]=o:n(this,{[e]:{value:o,writable:!0,enumerable:r.enumerable,configurable:r.configurable}})},enumerable:r.enumerable,configurable:r.configurable}})}}!function t(e,n){e&&n&&i(n).forEach(s=>{const c=n[s],l=e[s];switch(c){case!0:!function(t,e){if(!t)return;const n=r(t,e);n&&a(t,e,n)}(e,s);break;case"*":!function(t){if(!t)return;const e=o(t);e&&i(e).forEach(n=>a(t,n,e[n]))}(l);break;default:if(Object(c)!==c)throw TypeError(`Repair plan subPlan ${c} is invalid`);t(l,c)}})}(t,e)}const bt=["transforms"];return function(t,e){return{makeSESRootRealm:function(n){n=Object(n);const r=[],{dataPropertiesToRepair:o,shims:s,sloppyGlobals:i,whitelist:a}=n,c=Object.assign({},n);delete c.dataPropertiesToRepair,delete c.shims,delete c.sloppyGlobals,delete c.whitelist;const l=JSON.parse(JSON.stringify(a||dt)),u=void 0!==o?JSON.parse(JSON.stringify(o)):mt,h={};if(bt.forEach(t=>{t in c&&(h[t]=c[t])}),i)throw TypeError("sloppyGlobals cannot be specified for makeSESRootRealm!\nYou probably want a Compartment instead, like:\n  const c = s.global.Realm.makeCompartment({ sloppyGlobals: true })");"allow"!==n.dateNowMode&&r.push(`(${et})();`),"allow"!==n.mathRandomMode&&r.push(`(${nt})();`),"allow"!==n.intlMode&&r.push(`(${rt})();`),"allow"!==n.errorStackMode?r.push(`(${ot})();`):(l.namedIntrinsics.Error.captureStackTrace=!0,l.namedIntrinsics.Error.aabcTraceLimit=!0,l.namedIntrinsics.Error.prepareStackTrace=!0),"allow"!==n.regexpMode&&r.push(`(${st})();`);const p=`const getAnonIntrinsics = (${at});\n               (${it})(this, ${JSON.stringify(l)})`;r.push(p),s&&r.push(...s);const f=e.makeRootRealm(Object.assign({},h,{shims:r})),d=`(${tt})`,g=f.evaluate(d)();if(f.evaluate(t).createSESInThisRealm(f.global,t,f),f.global.SES.harden=g,"allow"===n.consoleMode){const t=`(${gt})`;f.global.console=f.evaluate(t)(console)}const y=f.evaluate(`(${at})`)(f.global),m=f.evaluate(`(${ct})`)(f.global,dt),w=f.evaluate(`(${ut})`)(m,y),b=f.evaluate(`(${lt})`)(f.global,y);return f.evaluate(`(${wt})`)(w,u),g(b),f.makeRequire=g(f.evaluate(`(${yt})`)(f,g)),f}}}("(function (exports) {\n  'use strict';\n\n  // Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  // based upon:\n  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n  // then copied from proposal-frozen-realms deep-freeze.js\n  // then copied from SES/src/bundle/deepFreeze.js\n\n  /**\n   * @typedef HardenerOptions\n   * @type {object}\n   * @property {WeakSet=} fringeSet WeakSet to use for the fringeSet\n   * @property {Function=} naivePrepareObject Call with object before hardening\n   */\n\n  /**\n   * Create a `harden` function.\n   *\n   * @param {Iterable} initialFringe Objects considered already hardened\n   * @param {HardenerOptions=} options Options for creation\n   */\n  function makeHardener(initialFringe, options = {}) {\n    const { freeze, getOwnPropertyDescriptors, getPrototypeOf } = Object;\n    const { ownKeys } = Reflect;\n\n    // Objects that we won't freeze, either because we've frozen them already,\n    // or they were one of the initial roots (terminals). These objects form\n    // the \"fringe\" of the hardened object graph.\n    let { fringeSet } = options;\n    if (fringeSet) {\n      if (\n        typeof fringeSet.add !== 'function' ||\n        typeof fringeSet.has !== 'function'\n      ) {\n        throw new TypeError(\n          `options.fringeSet must have add() and has() methods`,\n        );\n      }\n\n      // Populate the supplied fringeSet with our initialFringe.\n      if (initialFringe) {\n        for (const fringe of initialFringe) {\n          fringeSet.add(fringe);\n        }\n      }\n    } else {\n      // Use a new empty fringe.\n      fringeSet = new WeakSet(initialFringe);\n    }\n\n    const naivePrepareObject = options && options.naivePrepareObject;\n\n    function harden(root) {\n      const toFreeze = new Set();\n      const prototypes = new Map();\n      const paths = new WeakMap();\n\n      // If val is something we should be freezing but aren't yet,\n      // add it to toFreeze.\n      function enqueue(val, path) {\n        if (Object(val) !== val) {\n          // ignore primitives\n          return;\n        }\n        const type = typeof val;\n        if (type !== 'object' && type !== 'function') {\n          // future proof: break until someone figures out what it should do\n          throw new TypeError(`Unexpected typeof: ${type}`);\n        }\n        if (fringeSet.has(val) || toFreeze.has(val)) {\n          // Ignore if this is an exit, or we've already visited it\n          return;\n        }\n        // console.log(`adding ${val} to toFreeze`, val);\n        toFreeze.add(val);\n        paths.set(val, path);\n      }\n\n      function freezeAndTraverse(obj) {\n        // Apply the naive preparer if they specified one.\n        if (naivePrepareObject) {\n          naivePrepareObject(obj);\n        }\n\n        // Now freeze the object to ensure reactive\n        // objects such as proxies won't add properties\n        // during traversal, before they get frozen.\n\n        // Object are verified before being enqueued,\n        // therefore this is a valid candidate.\n        // Throws if this fails (strict mode).\n        freeze(obj);\n\n        // we rely upon certain commitments of Object.freeze and proxies here\n\n        // get stable/immutable outbound links before a Proxy has a chance to do\n        // something sneaky.\n        const proto = getPrototypeOf(obj);\n        const descs = getOwnPropertyDescriptors(obj);\n        const path = paths.get(obj) || 'unknown';\n\n        // console.log(`adding ${proto} to prototypes under ${path}`);\n        if (proto !== null && !prototypes.has(proto)) {\n          prototypes.set(proto, path);\n          paths.set(proto, `${path}.__proto__`);\n        }\n\n        ownKeys(descs).forEach(name => {\n          const pathname = `${path}.${String(name)}`;\n          // todo uncurried form\n          // todo: getOwnPropertyDescriptors is guaranteed to return well-formed\n          // descriptors, but they still inherit from Object.prototype. If\n          // someone has poisoned Object.prototype to add 'value' or 'get'\n          // properties, then a simple 'if (\"value\" in desc)' or 'desc.value'\n          // test could be confused. We use hasOwnProperty to be sure about\n          // whether 'value' is present or not, which tells us for sure that this\n          // is a data property.\n          const desc = descs[name];\n          if ('value' in desc) {\n            // todo uncurried form\n            enqueue(desc.value, `${pathname}`);\n          } else {\n            enqueue(desc.get, `${pathname}(get)`);\n            enqueue(desc.set, `${pathname}(set)`);\n          }\n        });\n      }\n\n      function dequeue() {\n        // New values added before forEach() has finished will be visited.\n        toFreeze.forEach(freezeAndTraverse); // todo curried forEach\n      }\n\n      function checkPrototypes() {\n        prototypes.forEach((path, p) => {\n          if (!(toFreeze.has(p) || fringeSet.has(p))) {\n            // all reachable properties have already been frozen by this point\n            let msg;\n            try {\n              msg = `prototype ${p} of ${path} is not already in the fringeSet`;\n            } catch (e) {\n              // `${(async _=>_).__proto__}` fails in most engines\n              msg =\n                'a prototype of something is not already in the fringeset (and .toString failed)';\n              try {\n                console.log(msg);\n                console.log('the prototype:', p);\n                console.log('of something:', path);\n              } catch (_e) {\n                // console.log might be missing in restrictive SES realms\n              }\n            }\n            throw new TypeError(msg);\n          }\n        });\n      }\n\n      function commit() {\n        // todo curried forEach\n        // we capture the real WeakSet.prototype.add above, in case someone\n        // changes it. The two-argument form of forEach passes the second\n        // argument as the 'this' binding, so we add to the correct set.\n        toFreeze.forEach(fringeSet.add, fringeSet);\n      }\n\n      enqueue(root);\n      dequeue();\n      // console.log(\"fringeSet\", fringeSet);\n      // console.log(\"prototype set:\", prototypes);\n      // console.log(\"toFreeze set:\", toFreeze);\n      checkPrototypes();\n      commit();\n\n      return root;\n    }\n\n    return harden;\n  }\n\n  function tameDate() {\n    const unsafeDate = Date;\n    // Date(anything) gives a string with the current time\n    // new Date(x) coerces x into a number and then returns a Date\n    // new Date() returns the current time, as a Date object\n    // new Date(undefined) returns a Date object which stringifies to 'Invalid Date'\n\n    const newDateConstructor = function Date(...args) {\n      if (new.target === undefined) {\n        // we were not called as a constructor\n        // this would normally return a string with the current time\n        return 'Invalid Date';\n      }\n      // constructor behavior: if we get arguments, we can safely pass them through\n      if (args.length > 0) {\n        return Reflect.construct(unsafeDate, args, new.target);\n        // todo: test that our constructor can still be subclassed\n      }\n      // no arguments: return a Date object, but invalid\n      return Reflect.construct(unsafeDate, [NaN], new.target);\n    };\n\n    Object.defineProperties(\n      newDateConstructor,\n      Object.getOwnPropertyDescriptors(unsafeDate),\n    );\n    // that will copy the .prototype too, so this next line is unnecessary\n    // newDateConstructor.prototype = unsafeDate.prototype;\n    unsafeDate.prototype.constructor = newDateConstructor;\n    // disable Date.now\n    newDateConstructor.now = () => NaN;\n\n    Date = newDateConstructor; // eslint-disable-line no-global-assign\n  }\n\n  function tameMath() {\n    // Math.random = () => 4; // https://www.xkcd.com/221\n    Math.random = () => {\n      throw Error('disabled');\n    };\n  }\n\n  /* eslint-disable-next-line no-redeclare */\n  /* global Intl */\n\n  function tameIntl() {\n    // todo: somehow fix these. These almost certainly don't enable the reading\n    // of side-channels, but we want things to be deterministic across\n    // runtimes. Best bet is to just disallow calling these functions without\n    // an explicit locale name.\n\n    // the whitelist may have deleted Intl entirely, so tolerate that\n    if (typeof Intl !== 'undefined') {\n      Intl.DateTimeFormat = () => {\n        throw Error('disabled');\n      };\n      Intl.NumberFormat = () => {\n        throw Error('disabled');\n      };\n      Intl.getCanonicalLocales = () => {\n        throw Error('disabled');\n      };\n    }\n    // eslint-disable-next-line no-extend-native\n    Object.prototype.toLocaleString = () => {\n      throw new Error('toLocaleString suppressed');\n    };\n  }\n\n  function tameError() {\n    if (!Object.isExtensible(Error)) {\n      throw Error('huh Error is not extensible');\n    }\n    /* this worked back when we were running it on a global, but stopped\n    working when we turned it into a shim */\n    /*\n    Object.defineProperty(Error.prototype, \"stack\",\n                          { get() { return 'stack suppressed'; } });\n    */\n    delete Error.captureStackTrace;\n    if ('captureStackTrace' in Error) {\n      throw Error('hey we could not remove Error.captureStackTrace');\n    }\n\n    // we might do this in the future\n    /*\n    const unsafeError = Error;\n    const newErrorConstructor = function Error(...args) {\n      return Reflect.construct(unsafeError, args, new.target);\n    };\n\n    newErrorConstructor.prototype = unsafeError.prototype;\n    newErrorConstructor.prototype.construct = newErrorConstructor;\n\n    Error = newErrorConstructor;\n\n    EvalError.__proto__ = newErrorConstructor;\n    RangeError.__proto__ = newErrorConstructor;\n    ReferenceError.__proto__ = newErrorConstructor;\n    SyntaxError.__proto__ = newErrorConstructor;\n    TypeError.__proto__ = newErrorConstructor;\n    URIError.__proto__ = newErrorConstructor;\n    */\n  }\n\n  function tameRegExp() {\n    delete RegExp.prototype.compile;\n    if ('compile' in RegExp.prototype) {\n      throw Error('hey we could not remove RegExp.prototype.compile');\n    }\n\n    // We want to delete RegExp.$1, as well as any other surprising properties.\n    // On some engines we can't just do 'delete RegExp.$1'.\n    const unsafeRegExp = RegExp;\n\n    // eslint-disable-next-line no-global-assign\n    RegExp = function RegExp(...args) {\n      return Reflect.construct(unsafeRegExp, args, new.target);\n    };\n    RegExp.prototype = unsafeRegExp.prototype;\n    unsafeRegExp.prototype.constructor = RegExp;\n\n    if ('$1' in RegExp) {\n      throw Error('hey we could not remove RegExp.$1');\n    }\n  }\n\n  /* global getAnonIntrinsics */\n\n  // Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  /* This is evaluated in an environment in which getAnonIntrinsics() is\n     already defined (by prepending the definition of getAnonIntrinsics to the\n     stringified removeProperties()), hence we don't use the following\n     import */\n  // import { getAnonIntrinsics } from './anonIntrinsics.js';\n\n  function removeProperties(global, whitelist) {\n    // walk global object, test against whitelist, delete\n\n    const uncurryThis = fn => (thisArg, ...args) =>\n      Reflect.apply(fn, thisArg, args);\n    const {\n      getOwnPropertyDescriptor: gopd,\n      getOwnPropertyNames: gopn,\n      keys,\n    } = Object;\n    const cleaning = new WeakMap();\n    const getProto = Object.getPrototypeOf;\n    const hop = uncurryThis(Object.prototype.hasOwnProperty);\n\n    const whiteTable = new WeakMap();\n\n    function addToWhiteTable(rootValue, rootPermit) {\n      /**\n       * The whiteTable should map from each path-accessible primordial\n       * object to the permit object that describes how it should be\n       * cleaned.\n       *\n       * We initialize the whiteTable only so that {@code getPermit} can\n       * process \"*\" inheritance using the whitelist, by walking actual\n       * inheritance chains.\n       */\n      const whitelistSymbols = [true, false, '*', 'maybeAccessor'];\n      function register(value, permit) {\n        if (value !== Object(value)) {\n          return;\n        }\n        if (typeof permit !== 'object') {\n          if (whitelistSymbols.indexOf(permit) < 0) {\n            throw new Error(\n              `syntax error in whitelist; unexpected value: ${permit}`,\n            );\n          }\n          return;\n        }\n        if (whiteTable.has(value)) {\n          throw new Error('primordial reachable through multiple paths');\n        }\n        whiteTable.set(value, permit);\n        keys(permit).forEach(name => {\n          // Use gopd to avoid invoking an accessor property.\n          // Accessor properties for which permit !== 'maybeAccessor'\n          // are caught later by clean().\n          const desc = gopd(value, name);\n          if (desc) {\n            register(desc.value, permit[name]);\n          }\n        });\n      }\n      register(rootValue, rootPermit);\n    }\n\n    /**\n     * Should the property named {@code name} be whitelisted on the\n     * {@code base} object, and if so, with what Permit?\n     *\n     * <p>If it should be permitted, return the Permit (where Permit =\n     * true | \"maybeAccessor\" | \"*\" | Record(Permit)), all of which are\n     * truthy. If it should not be permitted, return false.\n     */\n    function getPermit(base, name) {\n      let permit = whiteTable.get(base);\n      if (permit) {\n        if (hop(permit, name)) {\n          return permit[name];\n        }\n        // Allow escaping of magical names like '__proto__'.\n        if (hop(permit, `ESCAPE${name}`)) {\n          return permit[`ESCAPE${name}`];\n        }\n      }\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        base = getProto(base); // eslint-disable-line no-param-reassign\n        if (base === null) {\n          return false;\n        }\n        permit = whiteTable.get(base);\n        if (permit && hop(permit, name)) {\n          const result = permit[name];\n          if (result === '*') {\n            return result;\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Removes all non-whitelisted properties found by recursively and\n     * reflectively walking own property chains.\n     *\n     * <p>Inherited properties are not checked, because we require that\n     * inherited-from objects are otherwise reachable by this traversal.\n     */\n    function clean(value, prefix, num) {\n      if (value !== Object(value)) {\n        return;\n      }\n      if (cleaning.get(value)) {\n        return;\n      }\n\n      const proto = getProto(value);\n      if (proto !== null && !whiteTable.has(proto)) {\n        // reportItemProblem(rootReports, ses.severities.NOT_ISOLATED,\n        //                  'unexpected intrinsic', prefix + '.__proto__');\n        throw new Error(`unexpected intrinsic ${prefix}.__proto__`);\n      }\n\n      cleaning.set(value, true);\n      gopn(value).forEach(name => {\n        const path = prefix + (prefix ? '.' : '') + name;\n        const p = getPermit(value, name);\n        if (p) {\n          const desc = gopd(value, name);\n          if (hop(desc, 'value')) {\n            // Is a data property\n            const subValue = desc.value;\n            clean(subValue, path);\n          } else if (p !== 'maybeAccessor') {\n            // We are not saying that it is safe for the prop to be\n            // unexpectedly an accessor; rather, it will be deleted\n            // and thus made safe.\n            // reportProperty(ses.severities.SAFE_SPEC_VIOLATION,\n            //               'Not a data property', path);\n            delete value[name]; // eslint-disable-line no-param-reassign\n          } else {\n            clean(desc.get, `${path}<getter>`);\n            clean(desc.set, `${path}<setter>`);\n          }\n        } else {\n          delete value[name]; // eslint-disable-line no-param-reassign\n        }\n      });\n    }\n\n    addToWhiteTable(global, whitelist.namedIntrinsics);\n    const intr = getAnonIntrinsics(global);\n    addToWhiteTable(intr, whitelist.anonIntrinsics);\n    clean(global, '');\n  }\n\n  // Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // https://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  // TODO(erights): We should test for\n  // We now have a reason to omit Proxy from the whitelist.\n  // The makeBrandTester in repairES5 uses Allen's trick at\n  // https://esdiscuss.org/topic/tostringtag-spoofing-for-null-and-undefined#content-59\n  // , but testing reveals that, on FF 35.0.1, a proxy on an exotic\n  // object X will pass this brand test when X will. This is fixed as of\n  // FF Nightly 38.0a1.\n\n  /**\n   * <p>Qualifying platforms generally include all JavaScript platforms\n   * shown on <a href=\"http://kangax.github.com/es5-compat-table/\"\n   * >ECMAScript 5 compatibility table</a> that implement {@code\n   * Object.getOwnPropertyNames}. At the time of this writing,\n   * qualifying browsers already include the latest released versions of\n   * Internet Explorer (9), Firefox (4), Chrome (11), and Safari\n   * (5.0.5), their corresponding standalone (e.g., server-side) JavaScript\n   * engines, Rhino 1.73, and BESEN.\n   *\n   * <p>On such not-quite-ES5 platforms, some elements of these\n   * emulations may lose SES safety, as enumerated in the comment on\n   * each problem record in the {@code baseProblems} and {@code\n   * supportedProblems} array below. The platform must at least provide\n   * {@code Object.getOwnPropertyNames}, because it cannot reasonably be\n   * emulated.\n   *\n   * <p>This file is useful by itself, as it has no dependencies on the\n   * rest of SES. It creates no new global bindings, but merely repairs\n   * standard globals or standard elements reachable from standard\n   * globals. If the future-standard {@code WeakMap} global is present,\n   * as it is currently on FF7.0a1, then it will repair it in place. The\n   * one non-standard element that this file uses is {@code console} if\n   * present, in order to report the repairs it found necessary, in\n   * which case we use its {@code log, info, warn}, and {@code error}\n   * methods. If {@code console.log} is absent, then this file performs\n   * its repairs silently.\n   *\n   * <p>Generally, this file should be run as the first script in a\n   * JavaScript context (i.e. a browser frame), as it relies on other\n   * primordial objects and methods not yet being perturbed.\n   *\n   * <p>TODO(erights): This file tries to protect itself from some\n   * post-initialization perturbation by stashing some of the\n   * primordials it needs for later use, but this attempt is currently\n   * incomplete. We need to revisit this when we support Confined-ES5,\n   * as a variant of SES in which the primordials are not frozen. See\n   * previous failed attempt at <a\n   * href=\"https://codereview.appspot.com/5278046/\" >Speeds up\n   * WeakMap. Preparing to support unfrozen primordials.</a>. From\n   * analysis of this failed attempt, it seems that the only practical\n   * way to support CES is by use of two frames, where most of initSES\n   * runs in a SES frame, and so can avoid worrying about most of these\n   * perturbations.\n   */\n  function getAnonIntrinsics$1(global) {\n\n    const gopd = Object.getOwnPropertyDescriptor;\n    const getProto = Object.getPrototypeOf;\n\n    // ////////////// Undeniables and Intrinsics //////////////\n\n    /**\n     * The undeniables are the primordial objects which are ambiently\n     * reachable via compositions of strict syntax, primitive wrapping\n     * (new Object(x)), and prototype navigation (the equivalent of\n     * Object.getPrototypeOf(x) or x.__proto__). Although we could in\n     * theory monkey patch primitive wrapping or prototype navigation,\n     * we won't. Hence, without parsing, the following are undeniable no\n     * matter what <i>other</i> monkey patching we do to the primordial\n     * environment.\n     */\n\n    // The first element of each undeniableTuple is a string used to\n    // name the undeniable object for reporting purposes. It has no\n    // other programmatic use.\n    //\n    // The second element of each undeniableTuple should be the\n    // undeniable itself.\n    //\n    // The optional third element of the undeniableTuple, if present,\n    // should be an example of syntax, rather than use of a monkey\n    // patchable API, evaluating to a value from which the undeniable\n    // object in the second element can be reached by only the\n    // following steps:\n    // If the value is primitve, convert to an Object wrapper.\n    // Is the resulting object either the undeniable object, or does\n    // it inherit directly from the undeniable object?\n\n    function* aStrictGenerator() {} // eslint-disable-line no-empty-function\n    const Generator = getProto(aStrictGenerator);\n    // async function* aStrictAsyncGenerator() {} // eslint-disable-line no-empty-function\n    // const AsyncGenerator = getProto(aStrictAsyncGenerator);\n    async function aStrictAsyncFunction() {} // eslint-disable-line no-empty-function\n    const AsyncFunctionPrototype = getProto(aStrictAsyncFunction);\n\n    // TODO: this is dead code, but could be useful: make this the\n    // 'undeniables' object available via some API.\n\n    const undeniableTuples = [\n      ['Object.prototype', Object.prototype, {}],\n      ['Function.prototype', Function.prototype, function foo() {}],\n      ['Array.prototype', Array.prototype, []],\n      ['RegExp.prototype', RegExp.prototype, /x/],\n      ['Boolean.prototype', Boolean.prototype, true],\n      ['Number.prototype', Number.prototype, 1],\n      ['String.prototype', String.prototype, 'x'],\n      ['%Generator%', Generator, aStrictGenerator],\n      // ['%AsyncGenerator%', AsyncGenerator, aStrictAsyncGenerator],\n      ['%AsyncFunction%', AsyncFunctionPrototype, aStrictAsyncFunction],\n    ];\n\n    undeniableTuples.forEach(tuple => {\n      const name = tuple[0];\n      const undeniable = tuple[1];\n      let start = tuple[2];\n      if (start === undefined) {\n        return;\n      }\n      start = Object(start);\n      if (undeniable === start) {\n        return;\n      }\n      if (undeniable === getProto(start)) {\n        return;\n      }\n      throw new Error(`Unexpected undeniable: ${undeniable}`);\n    });\n\n    function registerIteratorProtos(registery, base, name) {\n      const iteratorSym =\n        (global.Symbol && global.Symbol.iterator) || '@@iterator'; // used instead of a symbol on FF35\n\n      if (base[iteratorSym]) {\n        const anIter = base[iteratorSym]();\n        const anIteratorPrototype = getProto(anIter);\n        registery[name] = anIteratorPrototype; // eslint-disable-line no-param-reassign\n        const anIterProtoBase = getProto(anIteratorPrototype);\n        if (anIterProtoBase !== Object.prototype) {\n          if (!registery.IteratorPrototype) {\n            if (getProto(anIterProtoBase) !== Object.prototype) {\n              throw new Error(\n                '%IteratorPrototype%.__proto__ was not Object.prototype',\n              );\n            }\n            registery.IteratorPrototype = anIterProtoBase; // eslint-disable-line no-param-reassign\n          } else if (registery.IteratorPrototype !== anIterProtoBase) {\n            throw new Error(`unexpected %${name}%.__proto__`);\n          }\n        }\n      }\n    }\n\n    /**\n     * Get the intrinsics not otherwise reachable by named own property\n     * traversal. See\n     * https://people.mozilla.org/~jorendorff/es6-draft.html#sec-well-known-intrinsic-objects\n     * and the instrinsics section of whitelist.js\n     *\n     * <p>Unlike getUndeniables(), the result of sampleAnonIntrinsics()\n     * does depend on the current state of the primordials, so we must\n     * run this again after all other relevant monkey patching is done,\n     * in order to properly initialize cajaVM.aayb\n     */\n\n    // TODO: we can probably unwrap this into the outer function, and stop\n    // using a separately named 'sampleAnonIntrinsics'\n    function sampleAnonIntrinsics() {\n      const result = {};\n\n      // If there are still other ThrowTypeError objects left after\n      // noFuncPoison-ing, this should be caught by\n      // test_THROWTYPEERROR_NOT_UNIQUE below, so we assume here that\n      // this is the only surviving ThrowTypeError intrinsic.\n      // eslint-disable-next-line prefer-rest-params\n      result.ThrowTypeError = gopd(arguments, 'callee').get;\n\n      // Get the ES6 %ArrayIteratorPrototype%,\n      // %StringIteratorPrototype%, %MapIteratorPrototype%,\n      // %SetIteratorPrototype% and %IteratorPrototype% intrinsics, if\n      // present.\n      registerIteratorProtos(result, [], 'ArrayIteratorPrototype');\n      registerIteratorProtos(result, '', 'StringIteratorPrototype');\n      if (typeof Map === 'function') {\n        registerIteratorProtos(result, new Map(), 'MapIteratorPrototype');\n      }\n      if (typeof Set === 'function') {\n        registerIteratorProtos(result, new Set(), 'SetIteratorPrototype');\n      }\n\n      // Get the ES6 %GeneratorFunction% intrinsic, if present.\n      if (getProto(Generator) !== Function.prototype) {\n        throw new Error('Generator.__proto__ was not Function.prototype');\n      }\n      const GeneratorFunction = Generator.constructor;\n      if (getProto(GeneratorFunction) !== Function.prototype.constructor) {\n        throw new Error(\n          'GeneratorFunction.__proto__ was not Function.prototype.constructor',\n        );\n      }\n      result.GeneratorFunction = GeneratorFunction;\n      const genProtoBase = getProto(Generator.prototype);\n      if (genProtoBase !== result.IteratorPrototype) {\n        throw new Error('Unexpected Generator.prototype.__proto__');\n      }\n\n      // Get the ES6 %AsyncGeneratorFunction% intrinsic, if present.\n      /*\n      if (getProto(AsyncGenerator) !== Function.prototype) {\n        throw new Error('AsyncGenerator.__proto__ was not Function.prototype');\n      }\n      const AsyncGeneratorFunction = AsyncGenerator.constructor;\n      if (getProto(AsyncGeneratorFunction) !== Function.prototype.constructor) {\n        throw new Error(\n          'AsyncGeneratorFunction.__proto__ was not Function.prototype.constructor',\n        );\n      }\n      result.AsyncGeneratorFunction = AsyncGeneratorFunction;\n      const AsyncGeneratorPrototype = AsyncGenerator.prototype;\n      result.AsyncIteratorPrototype = getProto(AsyncGeneratorPrototype);\n      // it appears that the only way to get an AsyncIteratorPrototype is\n      // through this getProto() process, so there's nothing to check it\n      // against\n      if (getProto(result.AsyncIteratorPrototype) !== Object.prototype) {\n        throw new Error(\n          'AsyncIteratorPrototype.__proto__ was not Object.prototype',\n        );\n      }\n      */\n\n      // Get the ES6 %AsyncFunction% intrinsic, if present.\n      if (getProto(AsyncFunctionPrototype) !== Function.prototype) {\n        throw new Error(\n          'AsyncFunctionPrototype.__proto__ was not Function.prototype',\n        );\n      }\n      const AsyncFunction = AsyncFunctionPrototype.constructor;\n      if (getProto(AsyncFunction) !== Function.prototype.constructor) {\n        throw new Error(\n          'AsyncFunction.__proto__ was not Function.prototype.constructor',\n        );\n      }\n      result.AsyncFunction = AsyncFunction;\n\n      // Get the ES6 %TypedArray% intrinsic, if present.\n      (function getTypedArray() {\n        if (!global.Float32Array) {\n          return;\n        }\n        const TypedArray = getProto(global.Float32Array);\n        if (TypedArray === Function.prototype) {\n          return;\n        }\n        if (getProto(TypedArray) !== Function.prototype) {\n          // http://bespin.cz/~ondras/html/classv8_1_1ArrayBufferView.html\n          // has me worried that someone might make such an intermediate\n          // object visible.\n          throw new Error('TypedArray.__proto__ was not Function.prototype');\n        }\n        result.TypedArray = TypedArray;\n      })();\n\n      Object.keys(result).forEach(name => {\n        if (result[name] === undefined) {\n          throw new Error(`Malformed intrinsic: ${name}`);\n        }\n      });\n\n      return result;\n    }\n\n    return sampleAnonIntrinsics();\n  }\n\n  function getNamedIntrinsics(unsafeGlobal, whitelist) {\n    const { defineProperty, getOwnPropertyDescriptor, ownKeys } = Reflect;\n\n    const namedIntrinsics = {};\n\n    const propertyNames = ownKeys(whitelist.namedIntrinsics);\n\n    for (const name of propertyNames) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        if ('get' in desc || 'set' in desc) {\n          throw new TypeError(`unexpected accessor on global property: ${name}`);\n        }\n\n        defineProperty(namedIntrinsics, name, desc);\n      }\n    }\n\n    return namedIntrinsics;\n  }\n\n  function getAllPrimordials(global, anonIntrinsics) {\n\n    const root = {\n      global, // global plus all the namedIntrinsics\n      anonIntrinsics,\n    };\n    // todo: re-examine exactly which \"global\" we're freezing\n\n    return root;\n  }\n\n  function getAllPrimordials$1(namedIntrinsics, anonIntrinsics) {\n\n    const root = {\n      namedIntrinsics,\n      anonIntrinsics,\n    };\n\n    return root;\n  }\n\n  // Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  /**\n   * @fileoverview Exports {@code ses.whitelist}, a recursively defined\n   * JSON record enumerating all the naming paths in the ES5.1 spec,\n   * those de-facto extensions that we judge to be safe, and SES and\n   * Dr. SES extensions provided by the SES runtime.\n   *\n   * <p>Assumes only ES3. Compatible with ES5, ES5-strict, or\n   * anticipated ES6.\n   *\n   * //provides ses.whitelist\n   * @author Mark S. Miller,\n   * @overrides ses, whitelistModule\n   */\n\n  /**\n   * <p>Each JSON record enumerates the disposition of the properties on\n   * some corresponding primordial object, with the root record\n   * representing the global object. For each such record, the values\n   * associated with its property names can be\n   * <ul>\n   * <li>Another record, in which case this property is simply\n   *     whitelisted and that next record represents the disposition of\n   *     the object which is its value. For example, {@code \"Object\"}\n   *     leads to another record explaining what properties {@code\n   *     \"Object\"} may have and how each such property, if present,\n   *     and its value should be tamed.\n   * <li>true, in which case this property is simply whitelisted. The\n   *     value associated with that property is still traversed and\n   *     tamed, but only according to the taming of the objects that\n   *     object inherits from. For example, {@code \"Object.freeze\"} leads\n   *     to true, meaning that the {@code \"freeze\"} property of {@code\n   *     Object} should be whitelisted and the value of the property (a\n   *     function) should be further tamed only according to the\n   *     markings of the other objects it inherits from, like {@code\n   *     \"Function.prototype\"} and {@code \"Object.prototype\").\n   *     If the property is an accessor property, it is not\n   *     whitelisted (as invoking an accessor might not be meaningful,\n   *     yet the accessor might return a value needing taming).\n   * <li>\"maybeAccessor\", in which case this accessor property is simply\n   *     whitelisted and its getter and/or setter are tamed according to\n   *     inheritance. If the property is not an accessor property, its\n   *     value is tamed according to inheritance.\n   * <li>\"*\", in which case this property on this object is whitelisted,\n   *     as is this property as inherited by all objects that inherit\n   *     from this object. The values associated with all such properties\n   *     are still traversed and tamed, but only according to the taming\n   *     of the objects that object inherits from. For example, {@code\n   *     \"Object.prototype.constructor\"} leads to \"*\", meaning that we\n   *     whitelist the {@code \"constructor\"} property on {@code\n   *     Object.prototype} and on every object that inherits from {@code\n   *     Object.prototype} that does not have a conflicting mark. Each\n   *     of these is tamed as if with true, so that the value of the\n   *     property is further tamed according to what other objects it\n   *     inherits from.\n   * <li>false, which suppresses permission inherited via \"*\".\n   * </ul>\n   *\n   * <p>TODO: We want to do for constructor: something weaker than '*',\n   * but rather more like what we do for [[Prototype]] links, which is\n   * that it is whitelisted only if it points at an object which is\n   * otherwise reachable by a whitelisted path.\n   *\n   * <p>The members of the whitelist are either\n   * <ul>\n   * <li>(uncommented) defined by the ES5.1 normative standard text,\n   * <li>(questionable) provides a source of non-determinism, in\n   *     violation of pure object-capability rules, but allowed anyway\n   *     since we've given up on restricting JavaScript to a\n   *     deterministic subset.\n   * <li>(ES5 Appendix B) common elements of de facto JavaScript\n   *     described by the non-normative Appendix B.\n   * <li>(Harmless whatwg) extensions documented at\n   *     <a href=\"http://wiki.whatwg.org/wiki/Web_ECMAScript\"\n   *     >http://wiki.whatwg.org/wiki/Web_ECMAScript</a> that seem to be\n   *     harmless. Note that the RegExp constructor extensions on that\n   *     page are <b>not harmless</b> and so must not be whitelisted.\n   * <li>(ES-Harmony proposal) accepted as \"proposal\" status for\n   *     EcmaScript-Harmony.\n   * </ul>\n   *\n   * <p>With the above encoding, there are some sensible whitelists we\n   * cannot express, such as marking a property both with \"*\" and a JSON\n   * record. This is an expedient decision based only on not having\n   * encountered such a need. Should we need this extra expressiveness,\n   * we'll need to refactor to enable a different encoding.\n   *\n   * <p>We factor out {@code true} into the variable {@code t} just to\n   * get a bit better compression from simple minifiers.\n   */\n\n  const t = true;\n  const j = true; // included in the Jessie runtime\n\n  let TypedArrayWhitelist; // defined and used below\n\n  var whitelist = {\n    // The accessible intrinsics which are not reachable by own\n    // property name traversal are listed here so that they are\n    // processed by the whitelist, although this also makes them\n    // accessible by this path.  See\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-well-known-intrinsic-objects\n    // Of these, ThrowTypeError is the only one from ES5. All the\n    // rest were introduced in ES6.\n    anonIntrinsics: {\n      ThrowTypeError: {},\n      IteratorPrototype: {\n        // 25.1\n        // Technically, for SES-on-ES5, we should not need to\n        // whitelist 'next'. However, browsers are accidentally\n        // relying on it\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4769#\n        // https://bugs.webkit.org/show_bug.cgi?id=154475\n        // and we will be whitelisting it as we transition to ES6\n        // anyway, so we unconditionally whitelist it now.\n        next: '*',\n        constructor: false,\n      },\n      ArrayIteratorPrototype: {},\n      StringIteratorPrototype: {},\n      MapIteratorPrototype: {},\n      SetIteratorPrototype: {},\n      // AsyncIteratorPrototype does not inherit from IteratorPrototype\n      AsyncIteratorPrototype: {},\n\n      // The %GeneratorFunction% intrinsic is the constructor of\n      // generator functions, so %GeneratorFunction%.prototype is\n      // the %Generator% intrinsic, which all generator functions\n      // inherit from. A generator function is effectively the\n      // constructor of its generator instances, so, for each\n      // generator function (e.g., \"g1\" on the diagram at\n      // http://people.mozilla.org/~jorendorff/figure-2.png )\n      // its .prototype is a prototype that its instances inherit\n      // from. Paralleling this structure, %Generator%.prototype,\n      // i.e., %GeneratorFunction%.prototype.prototype, is the\n      // object that all these generator function prototypes inherit\n      // from. The .next, .return and .throw that generator\n      // instances respond to are actually the builtin methods they\n      // inherit from this object.\n      GeneratorFunction: {\n        // 25.2\n        length: '*', // Not sure why this is needed\n        prototype: {\n          // 25.4\n          prototype: {\n            next: '*',\n            return: '*',\n            throw: '*',\n            constructor: '*', // Not sure why this is needed\n          },\n        },\n      },\n      AsyncGeneratorFunction: {\n        // 25.3\n        length: '*',\n        prototype: {\n          // 25.5\n          prototype: {\n            next: '*',\n            return: '*',\n            throw: '*',\n            constructor: '*', // Not sure why this is needed\n          },\n        },\n      },\n      AsyncFunction: {\n        // 25.7\n        length: '*',\n        prototype: '*',\n      },\n\n      TypedArray: (TypedArrayWhitelist = {\n        // 22.2\n        length: '*', // does not inherit from Function.prototype on Chrome\n        name: '*', // ditto\n        from: t,\n        of: t,\n        BYTES_PER_ELEMENT: '*',\n        prototype: {\n          buffer: 'maybeAccessor',\n          byteLength: 'maybeAccessor',\n          byteOffset: 'maybeAccessor',\n          copyWithin: '*',\n          entries: '*',\n          every: '*',\n          fill: '*',\n          filter: '*',\n          find: '*',\n          findIndex: '*',\n          forEach: '*',\n          includes: '*',\n          indexOf: '*',\n          join: '*',\n          keys: '*',\n          lastIndexOf: '*',\n          length: 'maybeAccessor',\n          map: '*',\n          reduce: '*',\n          reduceRight: '*',\n          reverse: '*',\n          set: '*',\n          slice: '*',\n          some: '*',\n          sort: '*',\n          subarray: '*',\n          values: '*',\n          BYTES_PER_ELEMENT: '*',\n        },\n      }),\n    },\n\n    namedIntrinsics: {\n      // In order according to\n      // http://www.ecma-international.org/ecma-262/ with chapter\n      // numbers where applicable\n\n      // 18 The Global Object\n\n      // 18.1\n      Infinity: j,\n      NaN: j,\n      undefined: j,\n\n      // 18.2\n      eval: j, // realms-shim depends on having indirect eval in the globals\n      isFinite: t,\n      isNaN: t,\n      parseFloat: t,\n      parseInt: t,\n      decodeURI: t,\n      decodeURIComponent: t,\n      encodeURI: t,\n      encodeURIComponent: t,\n\n      // 19 Fundamental Objects\n\n      Object: {\n        // 19.1\n        assign: t, // ES-Harmony\n        create: t,\n        defineProperties: t, // ES-Harmony\n        defineProperty: t,\n        entries: t, // ES-Harmony\n        freeze: j,\n        getOwnPropertyDescriptor: t,\n        getOwnPropertyDescriptors: t, // proposed ES-Harmony\n        getOwnPropertyNames: t,\n        getOwnPropertySymbols: t, // ES-Harmony\n        getPrototypeOf: t,\n        is: j, // ES-Harmony\n        isExtensible: t,\n        isFrozen: t,\n        isSealed: t,\n        keys: t,\n        preventExtensions: j,\n        seal: j,\n        setPrototypeOf: t, // ES-Harmony\n        values: t, // ES-Harmony\n\n        prototype: {\n          // B.2.2\n          // We need to prefix __proto__ with ESCAPE so that it doesn't\n          // just change the prototype of this object.\n          ESCAPE__proto__: 'maybeAccessor',\n          __defineGetter__: t,\n          __defineSetter__: t,\n          __lookupGetter__: t,\n          __lookupSetter__: t,\n\n          constructor: '*',\n          hasOwnProperty: t,\n          isPrototypeOf: t,\n          propertyIsEnumerable: t,\n          toLocaleString: '*',\n          toString: '*',\n          valueOf: '*',\n\n          // Generally allowed\n          [Symbol.iterator]: '*',\n          [Symbol.toPrimitive]: '*',\n          [Symbol.toStringTag]: '*',\n          [Symbol.unscopables]: '*',\n        },\n      },\n\n      Function: {\n        // 19.2\n        length: t,\n        prototype: {\n          apply: t,\n          bind: t,\n          call: t,\n          [Symbol.hasInstance]: '*',\n\n          // 19.2.4 instances\n          length: '*',\n          name: '*', // ES-Harmony\n          prototype: '*',\n          arity: '*', // non-std, deprecated in favor of length\n\n          // Generally allowed\n          [Symbol.species]: 'maybeAccessor', // ES-Harmony?\n        },\n      },\n\n      Boolean: {\n        // 19.3\n        prototype: t,\n      },\n\n      Symbol: {\n        // 19.4               all ES-Harmony\n        asyncIterator: t, // proposed? ES-Harmony\n        for: t,\n        hasInstance: t,\n        isConcatSpreadable: t,\n        iterator: t,\n        keyFor: t,\n        match: t,\n        matchAll: t,\n        replace: t,\n        search: t,\n        species: t,\n        split: t,\n        toPrimitive: t,\n        toStringTag: t,\n        unscopables: t,\n        prototype: t,\n      },\n\n      Error: {\n        // 19.5\n        prototype: {\n          name: '*',\n          message: '*',\n        },\n      },\n      // In ES6 the *Error \"subclasses\" of Error inherit from Error,\n      // since constructor inheritance generally mirrors prototype\n      // inheritance. As explained at\n      // https://code.google.com/p/google-caja/issues/detail?id=1963 ,\n      // debug.js hides away the Error constructor itself, and so needs\n      // to rewire these \"subclass\" constructors. Until we have a more\n      // general mechanism, please maintain this list of whitelisted\n      // subclasses in sync with the list in debug.js of subclasses to\n      // be rewired.\n      EvalError: {\n        prototype: t,\n      },\n      RangeError: {\n        prototype: t,\n      },\n      ReferenceError: {\n        prototype: t,\n      },\n      SyntaxError: {\n        prototype: t,\n      },\n      TypeError: {\n        prototype: t,\n      },\n      URIError: {\n        prototype: t,\n      },\n\n      // 20 Numbers and Dates\n\n      Number: {\n        // 20.1\n        EPSILON: t, // ES-Harmony\n        isFinite: j, // ES-Harmony\n        isInteger: t, // ES-Harmony\n        isNaN: j, // ES-Harmony\n        isSafeInteger: j, // ES-Harmony\n        MAX_SAFE_INTEGER: j, // ES-Harmony\n        MAX_VALUE: t,\n        MIN_SAFE_INTEGER: j, // ES-Harmony\n        MIN_VALUE: t,\n        NaN: t,\n        NEGATIVE_INFINITY: t,\n        parseFloat: t, // ES-Harmony\n        parseInt: t, // ES-Harmony\n        POSITIVE_INFINITY: t,\n        prototype: {\n          toExponential: t,\n          toFixed: t,\n          toPrecision: t,\n        },\n      },\n\n      Math: {\n        // 20.2\n        E: j,\n        LN10: j,\n        LN2: j,\n        LOG10E: t,\n        LOG2E: t,\n        PI: j,\n        SQRT1_2: t,\n        SQRT2: t,\n\n        abs: j,\n        acos: t,\n        acosh: t, // ES-Harmony\n        asin: t,\n        asinh: t, // ES-Harmony\n        atan: t,\n        atanh: t, // ES-Harmony\n        atan2: t,\n        cbrt: t, // ES-Harmony\n        ceil: j,\n        clz32: t, // ES-Harmony\n        cos: t,\n        cosh: t, // ES-Harmony\n        exp: t,\n        expm1: t, // ES-Harmony\n        floor: j,\n        fround: t, // ES-Harmony\n        hypot: t, // ES-Harmony\n        imul: t, // ES-Harmony\n        log: j,\n        log1p: t, // ES-Harmony\n        log10: j, // ES-Harmony\n        log2: j, // ES-Harmony\n        max: j,\n        min: j,\n        pow: j,\n        random: t, // questionable\n        round: j,\n        sign: t, // ES-Harmony\n        sin: t,\n        sinh: t, // ES-Harmony\n        sqrt: j,\n        tan: t,\n        tanh: t, // ES-Harmony\n        trunc: j, // ES-Harmony\n      },\n\n      // no-arg Date constructor is questionable\n      Date: {\n        // 20.3\n        now: t, // questionable\n        parse: t,\n        UTC: t,\n        prototype: {\n          // Note: coordinate this list with maintanence of repairES5.js\n          getDate: t,\n          getDay: t,\n          getFullYear: t,\n          getHours: t,\n          getMilliseconds: t,\n          getMinutes: t,\n          getMonth: t,\n          getSeconds: t,\n          getTime: t,\n          getTimezoneOffset: t,\n          getUTCDate: t,\n          getUTCDay: t,\n          getUTCFullYear: t,\n          getUTCHours: t,\n          getUTCMilliseconds: t,\n          getUTCMinutes: t,\n          getUTCMonth: t,\n          getUTCSeconds: t,\n          setDate: t,\n          setFullYear: t,\n          setHours: t,\n          setMilliseconds: t,\n          setMinutes: t,\n          setMonth: t,\n          setSeconds: t,\n          setTime: t,\n          setUTCDate: t,\n          setUTCFullYear: t,\n          setUTCHours: t,\n          setUTCMilliseconds: t,\n          setUTCMinutes: t,\n          setUTCMonth: t,\n          setUTCSeconds: t,\n          toDateString: t,\n          toISOString: t,\n          toJSON: t,\n          toLocaleDateString: t,\n          toLocaleString: t,\n          toLocaleTimeString: t,\n          toTimeString: t,\n          toUTCString: t,\n\n          // B.2.4\n          getYear: t,\n          setYear: t,\n          toGMTString: t,\n        },\n      },\n\n      // 21 Text Processing\n\n      String: {\n        // 21.2\n        fromCharCode: j,\n        fromCodePoint: t, // ES-Harmony\n        raw: j, // ES-Harmony\n        prototype: {\n          charAt: t,\n          charCodeAt: t,\n          codePointAt: t, // ES-Harmony\n          concat: t,\n          endsWith: j, // ES-Harmony\n          includes: t, // ES-Harmony\n          indexOf: j,\n          lastIndexOf: j,\n          localeCompare: t,\n          match: t,\n          normalize: t, // ES-Harmony\n          padEnd: t, // ES-Harmony\n          padStart: t, // ES-Harmony\n          repeat: t, // ES-Harmony\n          replace: t,\n          search: t,\n          slice: j,\n          split: t,\n          startsWith: j, // ES-Harmony\n          substring: t,\n          toLocaleLowerCase: t,\n          toLocaleUpperCase: t,\n          toLowerCase: t,\n          toUpperCase: t,\n          trim: t,\n\n          // B.2.3\n          substr: t,\n          anchor: t,\n          big: t,\n          blink: t,\n          bold: t,\n          fixed: t,\n          fontcolor: t,\n          fontsize: t,\n          italics: t,\n          link: t,\n          small: t,\n          strike: t,\n          sub: t,\n          sup: t,\n\n          trimLeft: t, // non-standard\n          trimRight: t, // non-standard\n\n          // 21.1.4 instances\n          length: '*',\n        },\n      },\n\n      RegExp: {\n        // 21.2\n        prototype: {\n          exec: t,\n          flags: 'maybeAccessor',\n          global: 'maybeAccessor',\n          ignoreCase: 'maybeAccessor',\n          [Symbol.match]: '*', // ES-Harmony\n          multiline: 'maybeAccessor',\n          [Symbol.replace]: '*', // ES-Harmony\n          [Symbol.search]: '*', // ES-Harmony\n          source: 'maybeAccessor',\n          [Symbol.split]: '*', // ES-Harmony\n          sticky: 'maybeAccessor',\n          test: t,\n          unicode: 'maybeAccessor', // ES-Harmony\n          dotAll: 'maybeAccessor', // proposed ES-Harmony\n\n          // B.2.5\n          compile: false, // UNSAFE. Purposely suppressed\n\n          // 21.2.6 instances\n          lastIndex: '*',\n          options: '*', // non-std\n        },\n      },\n\n      // 22 Indexed Collections\n\n      Array: {\n        // 22.1\n        from: j,\n        isArray: t,\n        of: j, // ES-Harmony?\n        prototype: {\n          concat: t,\n          copyWithin: t, // ES-Harmony\n          entries: t, // ES-Harmony\n          every: t,\n          fill: t, // ES-Harmony\n          filter: j,\n          find: t, // ES-Harmony\n          findIndex: t, // ES-Harmony\n          forEach: j,\n          includes: t, // ES-Harmony\n          indexOf: j,\n          join: t,\n          keys: t, // ES-Harmony\n          lastIndexOf: j,\n          map: j,\n          pop: j,\n          push: j,\n          reduce: j,\n          reduceRight: j,\n          reverse: t,\n          shift: j,\n          slice: j,\n          some: t,\n          sort: t,\n          splice: t,\n          unshift: j,\n          values: t, // ES-Harmony\n\n          // 22.1.4 instances\n          length: '*',\n        },\n      },\n\n      // 22.2 Typed Array stuff\n      // TODO: Not yet organized according to spec order\n\n      Int8Array: TypedArrayWhitelist,\n      Uint8Array: TypedArrayWhitelist,\n      Uint8ClampedArray: TypedArrayWhitelist,\n      Int16Array: TypedArrayWhitelist,\n      Uint16Array: TypedArrayWhitelist,\n      Int32Array: TypedArrayWhitelist,\n      Uint32Array: TypedArrayWhitelist,\n      Float32Array: TypedArrayWhitelist,\n      Float64Array: TypedArrayWhitelist,\n\n      // 23 Keyed Collections          all ES-Harmony\n\n      Map: {\n        // 23.1\n        prototype: {\n          clear: j,\n          delete: j,\n          entries: j,\n          forEach: j,\n          get: j,\n          has: j,\n          keys: j,\n          set: j,\n          size: 'maybeAccessor',\n          values: j,\n        },\n      },\n\n      Set: {\n        // 23.2\n        prototype: {\n          add: j,\n          clear: j,\n          delete: j,\n          entries: j,\n          forEach: j,\n          has: j,\n          keys: j,\n          size: 'maybeAccessor',\n          values: j,\n        },\n      },\n\n      WeakMap: {\n        // 23.3\n        prototype: {\n          // Note: coordinate this list with maintenance of repairES5.js\n          delete: j,\n          get: j,\n          has: j,\n          set: j,\n        },\n      },\n\n      WeakSet: {\n        // 23.4\n        prototype: {\n          add: j,\n          delete: j,\n          has: j,\n        },\n      },\n\n      // 24 Structured Data\n\n      ArrayBuffer: {\n        // 24.1            all ES-Harmony\n        isView: t,\n        length: t, // does not inherit from Function.prototype on Chrome\n        name: t, // ditto\n        prototype: {\n          byteLength: 'maybeAccessor',\n          slice: t,\n        },\n      },\n\n      // 24.2 TODO: Omitting SharedArrayBuffer for now\n\n      DataView: {\n        // 24.3               all ES-Harmony\n        length: t, // does not inherit from Function.prototype on Chrome\n        name: t, // ditto\n        BYTES_PER_ELEMENT: '*', // non-standard. really?\n        prototype: {\n          buffer: 'maybeAccessor',\n          byteOffset: 'maybeAccessor',\n          byteLength: 'maybeAccessor',\n          getFloat32: t,\n          getFloat64: t,\n          getInt8: t,\n          getInt16: t,\n          getInt32: t,\n          getUint8: t,\n          getUint16: t,\n          getUint32: t,\n          setFloat32: t,\n          setFloat64: t,\n          setInt8: t,\n          setInt16: t,\n          setInt32: t,\n          setUint8: t,\n          setUint16: t,\n          setUint32: t,\n        },\n      },\n\n      // 24.4 TODO: Omitting Atomics for now\n\n      JSON: {\n        // 24.5\n        parse: j,\n        stringify: j,\n      },\n\n      // 25 Control Abstraction Objects\n\n      Promise: {\n        // 25.4\n        all: j,\n        race: j,\n        reject: j,\n        resolve: j,\n        makeHandled: t, // eventual-send\n        prototype: {\n          catch: t,\n          then: j,\n          finally: t, // proposed ES-Harmony\n\n          // eventual-send\n          delete: t,\n          get: t,\n          put: t,\n          post: t,\n          invoke: t,\n          fapply: t,\n          fcall: t,\n\n          // nanoq.js\n          del: t,\n\n          // Temporary compat with the old makeQ.js\n          send: t,\n          end: t,\n        },\n      },\n\n      // nanoq.js\n      Q: {\n        all: t,\n        race: t,\n        reject: t,\n        resolve: t,\n\n        join: t,\n        isPassByCopy: t,\n        passByCopy: t,\n        makeRemote: t,\n        makeFar: t,\n\n        // Temporary compat with the old makeQ.js\n        shorten: t,\n        isPromise: t,\n        async: t,\n        rejected: t,\n        promise: t,\n        delay: t,\n        memoize: t,\n        defer: t,\n      },\n\n      // 26 Reflection\n\n      Reflect: {\n        // 26.1\n        apply: t,\n        construct: t,\n        defineProperty: t,\n        deleteProperty: t,\n        get: t,\n        getOwnPropertyDescriptor: t,\n        getPrototypeOf: t,\n        has: t,\n        isExtensible: t,\n        ownKeys: t,\n        preventExtensions: t,\n        set: t,\n        setPrototypeOf: t,\n      },\n\n      Proxy: {\n        // 26.2\n        revocable: t,\n      },\n\n      // Appendix B\n\n      // B.2.1\n      escape: t,\n      unescape: t,\n\n      // B.2.5 (RegExp.prototype.compile) is marked 'false' up in 21.2\n\n      // Other\n\n      StringMap: {\n        // A specialized approximation of ES-Harmony's Map.\n        prototype: {}, // Technically, the methods should be on the prototype,\n        // but doing so while preserving encapsulation will be\n        // needlessly expensive for current usage.\n      },\n\n      Realm: {\n        makeRootRealm: t,\n        makeCompartment: t,\n        prototype: {\n          global: 'maybeAccessor',\n          evaluate: t,\n        },\n      },\n\n      SES: {\n        confine: t,\n        confineExpr: t,\n        harden: t,\n      },\n\n      Nat: j,\n      def: j,\n    },\n  };\n\n  function makeConsole(parentConsole) {\n    /* 'parentConsole' is the parent Realm's original 'console' object. We must\n       wrap it, exposing a 'console' with a 'console.log' (and perhaps others)\n       to the local realm, without allowing access to the original 'console',\n       its return values, or its exception objects, any of which could be used\n       to break confinement via the unsafe Function constructor. */\n\n    // callAndWrapError is copied from proposal-realms/shim/src/realmFacade.js\n    // Like Realm.apply except that it catches anything thrown and rethrows it\n    // as an Error from this realm\n\n    const errorConstructors = new Map([\n      ['EvalError', EvalError],\n      ['RangeError', RangeError],\n      ['ReferenceError', ReferenceError],\n      ['SyntaxError', SyntaxError],\n      ['TypeError', TypeError],\n      ['URIError', URIError],\n    ]);\n\n    function callAndWrapError(target, ...args) {\n      try {\n        return target(...args);\n      } catch (err) {\n        if (Object(err) !== err) {\n          // err is a primitive value, which is safe to rethrow\n          throw err;\n        }\n        let eName;\n        let eMessage;\n        let eStack;\n        try {\n          // The child environment might seek to use 'err' to reach the\n          // parent's intrinsics and corrupt them. `${err.name}` will cause\n          // string coercion of 'err.name'. If err.name is an object (probably\n          // a String of the parent Realm), the coercion uses\n          // err.name.toString(), which is under the aacd of the parent. If\n          // err.name were a primitive (e.g. a number), it would use\n          // Number.toString(err.name), using the child's version of Number\n          // (which the child could modify to capture its argument for later\n          // use), however primitives don't have properties like .prototype so\n          // they aren't useful for an attack.\n          eName = `${err.name}`;\n          eMessage = `${err.message}`;\n          eStack = `${err.aabc || eMessage}`;\n          // eName/eMessage/eStack are now child-realm primitive strings, and\n          // safe to expose\n        } catch (ignored) {\n          // if err.name.toString() throws, keep the (parent realm) Error away\n          // from the child\n          throw new Error('unknown error');\n        }\n        const ErrorConstructor = errorConstructors.get(eName) || Error;\n        try {\n          throw new ErrorConstructor(eMessage);\n        } catch (err2) {\n          err2.aabc = eStack; // replace with the captured inner stack\n          throw err2;\n        }\n      }\n    }\n\n    const newConsole = {};\n    const passThrough = [\n      'log',\n      'info',\n      'warn',\n      'error',\n      'group',\n      'groupEnd',\n      'trace',\n      'time',\n      'timeLog',\n      'timeEnd',\n    ];\n    // TODO: those are the properties that MDN documents. Node.js has a bunch\n    // of additional ones that I didn't include, which might be appropriate.\n\n    passThrough.forEach(name => {\n      // TODO: do we reveal the presence/absence of these properties to the\n      // child realm, thus exposing nondeterminism (and a hint of what platform\n      // you might be on) when it is constructed with {consoleMode: allow} ? Or\n      // should we expose the same set all the time, but silently ignore calls\n      // to the missing ones, to hide that variation? We might even consider\n      // adding console.* to the child realm all the time, even without\n      // consoleMode:allow, but ignore the calls unless the mode is enabled.\n      if (name in parentConsole) {\n        const orig = parentConsole[name];\n        // TODO: in a stack trace, this appears as\n        // \"Object.newConsole.(anonymous function) [as trace]\"\n        // can we make that \"newConsole.trace\" ?\n        newConsole[name] = function newerConsole(...args) {\n          callAndWrapError(orig, ...args);\n        };\n      }\n    });\n\n    return newConsole;\n  }\n\n  function makeMakeRequire(r, harden) {\n    function makeRequire(config) {\n      const cache = new Map();\n\n      function build(what) {\n        // This approach denies callers the ability to use inheritance to\n        // manage their config objects, but a simple \"if (what in config)\"\n        // predicate would also be truthy for e.g. \"toString\" and other\n        // properties of Object.prototype, and require('toString') should be\n        // legal if and only if the config object included an own-property\n        // named 'toString'. Incidentally, this could have been\n        // \"config.hasOwnProperty(what)\" but eslint complained.\n        if (!Object.prototype.hasOwnProperty.call(config, what)) {\n          throw new Error(`Cannot find module '${what}'`);\n        }\n        const c = config[what];\n\n        // some modules are hard-coded ways to access functionality that SES\n        // provides directly\n        if (what === '@agoric/harden') {\n          return harden;\n        }\n\n        // If the config points at a simple function, it must be a pure\n        // function with no dependencies (i.e. no 'require' or 'import', no\n        // calls to other functions defined in the same file but outside the\n        // function body). We stringify it and evaluate it inside this realm.\n        if (typeof c === 'function') {\n          return r.evaluate(`(${c})`);\n        }\n\n        // else we treat it as an object with an 'attenuatorSource' property\n        // that defines an attenuator function, which we evaluate. We then\n        // invoke it with the config object, which can contain authorities that\n        // it can wrap. The return value from this invocation is the module\n        // object that gets returned from require(). The attenuator function\n        // and the module it returns are in-realm, the authorities it wraps\n        // will be out-of-realm.\n        const src = `(${c.attenuatorSource})`;\n        const attenuator = r.evaluate(src);\n        return attenuator(c);\n      }\n\n      function newRequire(whatArg) {\n        const what = `${whatArg}`;\n        if (!cache.has(what)) {\n          cache.set(what, harden(build(what)));\n        }\n        return cache.get(what);\n      }\n\n      return newRequire;\n    }\n\n    return makeRequire;\n  }\n\n  /**\n   * @fileoverview Exports {@code ses.dataPropertiesToRepair}, a recursively\n   * defined JSON record enumerating the optimal set of prototype properties\n   * on primordials that need to be repaired before hardening.\n   *\n   * //provides ses.dataPropertiesToRepair\n   * @author JF Paradis\n   */\n\n  /**\n   * <p>The optimal set of prototype properties that need to be repaired\n   * before hardening is applied on enviromments subject to the override\n   * mistake.\n   *\n   * <p>Because \"repairing\" replaces data properties with accessors, every\n   * time a repaired property is accessed, the associated getter is invoked,\n   * which degrades the runtime performance of all code executing in the\n   * repaired enviromment, compared to the non-repaired case. In order\n   * to maintain performance, we only repair the properties of objects\n   * for which hardening causes a breakage of their intended usage. There\n   * are three cases:\n   * <ul>Overriding properties on objects typically used as maps,\n   *     namely {@code \"Object\"} and {@code \"Array\"}. In the case of arrays,\n   *     a given program might not be aware that non-numerical properties are\n   *     stored on the undelying object instance, not on the array. When an\n   *     object is typically used as a map, we repair all of its prototype\n   *     properties.\n   * <ul>Overriding properties on objects that provide defaults on their\n   *     prototype that programs typically override by assignment, such as\n   *     {@code \"Error.prototype.message\"} and {@code \"Function.prototype.name\"}\n   *     (both default to \"\").\n   * <ul>Setting a prototype chain. The constructor is typically set by\n   *     assignment, for example {@code \"Child.prototype.constructor = Child\"}.\n   *\n   * <p>Each JSON record enumerates the disposition of the properties on\n   * some corresponding primordial object, with the root record containing:\n   * <ul>\n   * <li>The record for the global object.\n   * <li>The record for the anonymous intrinsics.\n   * </ul>\n   *\n   * <p>For each such record, the values associated with its property\n   * names can be:\n   * <ul>\n   * <li>Another record, in which case this property is simply left\n   *     unrepaired and that next record represents the disposition of\n   *     the object which is its value. For example, {@code \"Object\"}\n   *     leads to another record explaining what properties {@code\n   *     \"Object\"} may have and how each such property, if present,\n   *     and its value should be repaired.\n   * <li>true, in which case this property is simply repaired. The\n   *     value associated with that property is not traversed. For\n   * \t   example, {@code \"Function.prototype.name\"} leads to true,\n   *     meaning that the {@code \"name\"} property of {@code\n   *     \"Function.prototype\"} should be repaired (which is needed\n   *     when inheriting from @code{Function} and setting the subclass's\n   *     {@code \"prototype.name\"} property). If the property is\n   *     already an accessor property, it is not repaired (because\n   *     accessors are not subject to the override mistake).\n   * <li>\"*\", all properties on this object are repaired.\n   * <li>falsey, in which case this property is skipped.\n   * </ul>\n   *\n   * <p>We factor out {@code true} into the variable {@code t} just to\n   * get a bit better compression from simple minifiers.\n   */\n\n  const t$1 = true;\n\n  var dataPropertiesToRepair = {\n    namedIntrinsics: {\n      Object: {\n        prototype: '*',\n      },\n\n      Array: {\n        prototype: '*',\n      },\n\n      Function: {\n        prototype: {\n          constructor: t$1, // set by \"regenerator-runtime\"\n          bind: t$1, // set by \"underscore\"\n          name: t$1,\n          toString: t$1,\n        },\n      },\n\n      Error: {\n        prototype: {\n          constructor: t$1, // set by \"fast-json-patch\"\n          message: t$1,\n          name: t$1, // set by \"precond\"\n          toString: t$1, // set by \"bluebird\"\n        },\n      },\n\n      TypeError: {\n        prototype: {\n          constructor: t$1, // set by \"readable-stream\"\n          name: t$1, // set by \"readable-stream\"\n        },\n      },\n\n      Promise: {\n        prototype: {\n          constructor: t$1, // set by \"core-js\"\n        },\n      },\n    },\n\n    anonIntrinsics: {\n      TypedArray: {\n        prototype: '*',\n      },\n\n      GeneratorFunction: {\n        prototype: {\n          constructor: t$1,\n          name: t$1,\n          toString: t$1,\n        },\n      },\n\n      AsyncFunction: {\n        prototype: {\n          constructor: t$1,\n          name: t$1,\n          toString: t$1,\n        },\n      },\n\n      AsyncGeneratorFunction: {\n        prototype: {\n          constructor: t$1,\n          name: t$1,\n          toString: t$1,\n        },\n      },\n\n      IteratorPrototype: '*',\n    },\n  };\n\n  // Adapted from SES/Caja\n  // Copyright (C) 2011 Google Inc.\n  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n  function repairDataProperties(intrinsics, repairPlan) {\n    // Object.defineProperty is allowed to fail silently,\n    // use Object.defineProperties instead.\n\n    const {\n      defineProperties,\n      getOwnPropertyDescriptor,\n      getOwnPropertyDescriptors,\n      prototype: { hasOwnProperty },\n    } = Object;\n\n    const { ownKeys } = Reflect;\n\n    /**\n     * For a special set of properties (defined in the repairPlan), it ensures\n     * that the effect of freezing does not suppress the ability to override\n     * these properties on derived objects by simple assignment.\n     *\n     * Because of lack of sufficient foresight at the time, ES5 unfortunately\n     * specified that a simple assignment to a non-existent property must fail if\n     * it would override a non-writable data property of the same name. (In\n     * retrospect, this was a mistake, but it is now too late and we must live\n     * with the consequences.) As a result, simply freezing an object to make it\n     * tamper proof has the unfortunate side effect of breaking previously correct\n     * code that is considered to have followed JS best practices, if this\n     * previous code used assignment to override.\n     */\n    function enableDerivedOverride(obj, prop, desc) {\n      if ('value' in desc && desc.configurable) {\n        const { value } = desc;\n\n        // eslint-disable-next-line no-inner-declarations\n        function getter() {\n          return value;\n        }\n\n        // Re-attach the data property on the object so\n        // it can be found by the deep-freeze traversal process.\n        getter.value = value;\n\n        // eslint-disable-next-line no-inner-declarations\n        function setter(newValue) {\n          if (obj === this) {\n            throw new TypeError(\n              `Cannot assign to read only property '${prop}' of object '${obj}'`,\n            );\n          }\n          if (hasOwnProperty.call(this, prop)) {\n            this[prop] = newValue;\n          } else {\n            defineProperties(this, {\n              [prop]: {\n                value: newValue,\n                writable: true,\n                enumerable: desc.enumerable,\n                configurable: desc.configurable,\n              },\n            });\n          }\n        }\n\n        defineProperties(obj, {\n          [prop]: {\n            get: getter,\n            set: setter,\n            enumerable: desc.enumerable,\n            configurable: desc.configurable,\n          },\n        });\n      }\n    }\n\n    function repairOneProperty(obj, prop) {\n      if (!obj) {\n        return;\n      }\n      const desc = getOwnPropertyDescriptor(obj, prop);\n      if (!desc) {\n        return;\n      }\n      enableDerivedOverride(obj, prop, desc);\n    }\n\n    function repairAllProperties(obj) {\n      if (!obj) {\n        return;\n      }\n      const descs = getOwnPropertyDescriptors(obj);\n      if (!descs) {\n        return;\n      }\n      ownKeys(descs).forEach(prop =>\n        enableDerivedOverride(obj, prop, descs[prop]),\n      );\n    }\n\n    function walkRepairPlan(obj, plan) {\n      if (!obj) {\n        return;\n      }\n      if (!plan) {\n        return;\n      }\n      ownKeys(plan).forEach(prop => {\n        const subPlan = plan[prop];\n        const subObj = obj[prop];\n        switch (subPlan) {\n          case true:\n            repairOneProperty(obj, prop);\n            break;\n\n          case '*':\n            repairAllProperties(subObj);\n            break;\n\n          default:\n            if (Object(subPlan) !== subPlan) {\n              throw TypeError(`Repair plan subPlan ${subPlan} is invalid`);\n            }\n            walkRepairPlan(subObj, subPlan);\n        }\n      });\n    }\n\n    // Do the repair.\n    walkRepairPlan(intrinsics, repairPlan);\n  }\n\n  // Copyright (C) 2018 Agoric\n\n  const FORWARDED_REALMS_OPTIONS = ['transforms'];\n\n  function createSESWithRealmConstructor(creatorStrings, Realm) {\n    function makeSESRootRealm(options) {\n      // eslint-disable-next-line no-param-reassign\n      options = Object(options); // Todo: sanitize\n      const shims = [];\n\n      const {\n        dataPropertiesToRepair: optDataPropertiesToRepair,\n        shims: optionalShims,\n        sloppyGlobals,\n        whitelist: optWhitelist\n      } = options;\n\n      const optionsRest = Object.assign({}, options);\n      delete optionsRest.dataPropertiesToRepair;\n      delete optionsRest.shims;\n      delete optionsRest.sloppyGlobals;\n      delete optionsRest.whitelist;\n\n      const wl = JSON.parse(JSON.stringify(optWhitelist || whitelist));\n      const repairPlan =\n        optDataPropertiesToRepair !== undefined\n          ? JSON.parse(JSON.stringify(optDataPropertiesToRepair))\n          : dataPropertiesToRepair;\n\n      // Forward the designated Realms options.\n      const realmsOptions = {};\n      FORWARDED_REALMS_OPTIONS.forEach(key => {\n        if (key in optionsRest) {\n          realmsOptions[key] = optionsRest[key];\n        }\n      });\n\n      if (sloppyGlobals) {\n        throw TypeError(`\\\nsloppyGlobals cannot be specified for makeSESRootRealm!\nYou probably want a Compartment instead, like:\n  const c = s.global.Realm.makeCompartment({ sloppyGlobals: true })`);\n      }\n\n      // \"allow\" enables real Date.now(), anything else gets NaN\n      // (it'd be nice to allow a fixed numeric value, but too hard to\n      // implement right now)\n      if (options.dateNowMode !== 'allow') {\n        shims.push(`(${tameDate})();`);\n      }\n\n      if (options.mathRandomMode !== 'allow') {\n        shims.push(`(${tameMath})();`);\n      }\n\n      // Intl is disabled entirely for now, deleted by removeProperties. If we\n      // want to bring it back (under the aacd of this option), we'll need\n      // to add it to the whitelist too, as well as taming it properly.\n      if (options.intlMode !== 'allow') {\n        // this shim also disables Object.prototype.toLocaleString\n        shims.push(`(${tameIntl})();`);\n      }\n\n      if (options.errorStackMode !== 'allow') {\n        shims.push(`(${tameError})();`);\n      } else {\n        // if removeProperties cleans these things from Error, v8 won't provide\n        // stack traces or even toString on exceptions, and then Node.js prints\n        // uncaught exceptions as \"undefined\" instead of a type/message/stack.\n        // So if we're allowing stack traces, make sure the whitelist is\n        // augmented to include them.\n        wl.namedIntrinsics.Error.captureStackTrace = true;\n        wl.namedIntrinsics.Error.aabcTraceLimit = true;\n        wl.namedIntrinsics.Error.prepareStackTrace = true;\n      }\n\n      if (options.regexpMode !== 'allow') {\n        shims.push(`(${tameRegExp})();`);\n      }\n\n      // The getAnonIntrinsics function might be renamed by e.g. rollup. The\n      // removeProperties() function references it by name, so we need to force\n      // it to have a specific name.\n      const removeProp = `const getAnonIntrinsics = (${getAnonIntrinsics$1});\n               (${removeProperties})(this, ${JSON.stringify(wl)})`;\n      shims.push(removeProp);\n\n      // Add options.shims.\n      if (optionalShims) {\n        shims.push(...optionalShims);\n      }\n\n      const r = Realm.makeRootRealm(Object.assign({}, realmsOptions, { shims }));\n\n      // Build a harden() with an empty fringe. It will be populated later when\n      // we call harden(allIntrinsics).\n      const makeHardenerSrc = `(${makeHardener})`;\n      const harden = r.evaluate(makeHardenerSrc)();\n\n      const b = r.evaluate(creatorStrings);\n      b.createSESInThisRealm(r.global, creatorStrings, r);\n\n      // Allow harden to be accessible via the SES global.\n      r.global.SES.harden = harden;\n\n      if (options.consoleMode === 'allow') {\n        const s = `(${makeConsole})`;\n        r.global.console = r.evaluate(s)(console);\n      }\n\n      // Extract the intrinsics from the global.\n      const anonIntrinsics = r.evaluate(`(${getAnonIntrinsics$1})`)(r.global);\n      const namedIntrinsics = r.evaluate(`(${getNamedIntrinsics})`)(\n        r.global,\n        whitelist,\n      );\n\n      // Gather the intrinsics only.\n      const allIntrinsics = r.evaluate(`(${getAllPrimordials$1})`)(\n        namedIntrinsics,\n        anonIntrinsics,\n      );\n\n      // Gather the primordials and the globals.\n      const allPrimordials = r.evaluate(`(${getAllPrimordials})`)(\n        r.global,\n        anonIntrinsics,\n      );\n\n      // Repair the override mistake on the intrinsics only.\n      r.evaluate(`(${repairDataProperties})`)(allIntrinsics, repairPlan);\n\n      // Finally freeze all the primordials, and the global object. This must\n      // be the last thing we do that modifies the Realm's globals.\n      harden(allPrimordials);\n\n      // build the makeRequire helper, glue it to the new Realm\n      r.makeRequire = harden(r.evaluate(`(${makeMakeRequire})`)(r, harden));\n      return r;\n    }\n    const SES = {\n      makeSESRootRealm,\n    };\n\n    return SES;\n  }\n\n  function createSESInThisRealm(global, creatorStrings, parentRealm) {\n    // eslint-disable-next-line no-param-reassign,no-undef\n    global.SES = createSESWithRealmConstructor(creatorStrings, Realm);\n    // todo: wrap exceptions, effectively undoing the wrapping that\n    // Realm.evaluate does\n\n    const errorConstructors = new Map([\n      ['EvalError', EvalError],\n      ['RangeError', RangeError],\n      ['ReferenceError', ReferenceError],\n      ['SyntaxError', SyntaxError],\n      ['TypeError', TypeError],\n      ['URIError', URIError],\n    ]);\n\n    // callAndWrapError is copied from the Realm shim. Our SES.confine (from\n    // inside the realm) delegates to Realm.evaluate (from outside the realm),\n    // but we need the exceptions to come from our own realm, so we use this to\n    // reverse the shim's own callAndWrapError. TODO: look for a reasonable way\n    // to avoid the double-wrapping, maybe by changing the shim/Realms-spec to\n    // provide the safeEvaluator as a Realm.evaluate method (inside a realm).\n    // That would make this trivial: global.SES = Realm.evaluate (modulo\n    // potential 'this' issues)\n\n    // the comments here were written from the POV of a parent defending itself\n    // against a malicious child realm. In this case, we are the child.\n\n    function callAndWrapError(target, ...args) {\n      try {\n        return target(...args);\n      } catch (err) {\n        if (Object(err) !== err) {\n          // err is a primitive value, which is safe to rethrow\n          throw err;\n        }\n        let eName;\n        let eMessage;\n        let eStack;\n        try {\n          // The child environment might seek to use 'err' to reach the\n          // parent's intrinsics and corrupt them. `${err.name}` will cause\n          // string coercion of 'err.name'. If err.name is an object (probably\n          // a String of the parent Realm), the coercion uses\n          // err.name.toString(), which is under the aacd of the parent. If\n          // err.name were a primitive (e.g. a number), it would use\n          // Number.toString(err.name), using the child's version of Number\n          // (which the child could modify to capture its argument for later\n          // use), however primitives don't have properties like .prototype so\n          // they aren't useful for an attack.\n          eName = `${err.name}`;\n          eMessage = `${err.message}`;\n          eStack = `${err.aabc || eMessage}`;\n          // eName/eMessage/eStack are now child-realm primitive strings, and\n          // safe to expose\n        } catch (ignored) {\n          // if err.name.toString() throws, keep the (parent realm) Error away\n          // from the child\n          throw new Error('unknown error');\n        }\n        const ErrorConstructor = errorConstructors.get(eName) || Error;\n        try {\n          throw new ErrorConstructor(eMessage);\n        } catch (err2) {\n          err2.aabc = eStack; // replace with the captured inner stack\n          throw err2;\n        }\n      }\n    }\n\n    // We must not allow other child code to access that object. SES.confine\n    // closes over the parent's Realm object so it shouldn't be accessible from\n    // the outside.\n\n    // eslint-disable-next-line no-param-reassign\n    global.SES.confine = (code, endowments) =>\n      callAndWrapError(() => parentRealm.evaluate(code, endowments));\n    // eslint-disable-next-line no-param-reassign\n    global.SES.confineExpr = (code, endowments) =>\n      callAndWrapError(() => parentRealm.evaluate(`(${code})`, endowments));\n  }\n\n  exports.createSESInThisRealm = createSESInThisRealm;\n  exports.createSESWithRealmConstructor = createSESWithRealmConstructor;\n\n  return exports;\n\n}({}))",Z)}()},function(module,exports){var indexOf=function(t,e){if(t.indexOf)return t.indexOf(e);for(var n=0;n<t.length;n++)if(t[n]===e)return n;return-1},Object_keys=function(t){if(Object.keys)return Object.keys(t);var e=[];for(var n in t)e.push(n);return e},forEach=function(t,e){if(t.forEach)return t.forEach(e);for(var n=0;n<t.length;n++)e(t[n],n,t)},defineProp=function(){try{return Object.defineProperty({},"_",{}),function(t,e,n){Object.defineProperty(t,e,{writable:!0,enumerable:!1,configurable:!0,value:n})}}catch(t){return function(t,e,n){t[e]=n}}}(),globals=["Array","Boolean","Date","Error","EvalError","Function","Infinity","JSON","Math","NaN","Number","Object","RangeError","ReferenceError","RegExp","String","SyntaxError","TypeError","URIError","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"];function Context(){}Context.prototype={};var Script=exports.Script=function(t){if(!(this instanceof Script))return new Script(t);this.code=t};Script.prototype.runInContext=function(t){if(!(t instanceof Context))throw new TypeError("needs a 'context' argument.");var e=document.createElement("iframe");e.style||(e.style={}),e.style.display="none",document.body.appendChild(e);var n=e.contentWindow,r=n.eval,o=n.execScript;!r&&o&&(o.call(n,"null"),r=n.eval),forEach(Object_keys(t),(function(e){n[e]=t[e]})),forEach(globals,(function(e){t[e]&&(n[e]=t[e])}));var s=Object_keys(n),i=r.call(n,this.code);return forEach(Object_keys(n),(function(e){(e in t||-1===indexOf(s,e))&&(t[e]=n[e])})),forEach(globals,(function(e){e in t||defineProp(t,e,n[e])})),document.body.removeChild(e),i},Script.prototype.runInThisContext=function(){return eval(this.code)},Script.prototype.runInNewContext=function(t){var e=Script.createContext(t),n=this.runInContext(e);return t&&forEach(Object_keys(e),(function(n){t[n]=e[n]})),n},forEach(Object_keys(Script.prototype),(function(t){exports[t]=Script[t]=function(e){var n=Script(e);return n[t].apply(n,[].slice.call(arguments,1))}})),exports.isContext=function(t){return t instanceof Context},exports.createScript=function(t){return exports.Script(t)},exports.createContext=Script.createContext=function(t){var e=new Context;return"object"==typeof t&&forEach(Object_keys(t),(function(n){e[n]=t[n]})),e}},function(t,e,n){const{aadd:r}=n(8),util=n(2);t.exports=class{constructor(t){this.run=t,this.blockchain=t.blockchain,this.code=t.code,this.state=t.state,this.pay=(...e)=>t.purse.pay(...e),this.sign=(...e)=>t.owner.sign(...e),this.aazc=[],this.aawc=[],this.aayc=new Map,this.aaxc=new Set}aalb(t){for(const[e,n]of t.locations)this.aayc.has(e)||this.aayc.set(e,n);this.aazc.push(t),1===this.aazc.length&&this.aakb().catch(t=>{})}async aakb(){const t=this.aazc[0];if(!t.actions.length&&!t.code.length)return this.aajb();const e=util.aas(this.blockchain.network);let r=null;try{const e=t.aapb(this.run),{refs:n,aajd:o,aakd:s}=e;r=e.tx;const i=n.map(t=>t.slice(0,64)),a=n.map(t=>parseInt(t.slice(66)));(i.length?await Promise.all(i.map(t=>this.blockchain.fetch(t))):[]).forEach((t,e)=>{if(void 0===t.outputs[a[e]].spentTxId)throw new Error(`Read ${n[e]} may not be latest. Blockchain did not return spentTxId. Aborting.`);if(null!==t.outputs[a[e]].spentTxId)throw new Error(`Read ${n[e]} is not the latest. Must sync() jigs`)}),t.imported||(r=await this.pay(r)),r=await this.sign(r);for(let t=0;t<o.length;t++)if(!r.inputs[t].isFullySigned())throw new Error(`Signature missing for ${o[t].constructor.name}\n\norigin: ${o[t].origin}\nlocation: ${s[t]}\nowner: ${o[t].owner}`);await this.broadcast(r),this.aaxc.forEach(t=>t(r))}catch(t){const e=0===this.aawc.length;return e&&this.run.logger.error(`Unhandled ${t.toString()}`),this.aawc.forEach(e=>e.reject(t)),this.aawc=[],this.aazc.forEach(n=>n.rollback(this.aayc,this.run,t,e)),this.aazc=[],void(this.aayc=new Map)}const o=t=>this.aazc.slice(1).some(e=>e.outputs.some(e=>util.aar(t,e)));t.outputs.forEach((e,n)=>{const s=1+t.code.length+n;"_"===e.origin[0]&&(e.origin=`${r.hash}_o${s}`),o(e)?this.aayc.set(e.origin,`${r.hash}_o${s}`):(e.location=`${r.hash}_o${s}`,this.aayc.delete(e.origin)),t.stateAfter.get(e).json.origin=e.origin,t.stateAfter.get(e).json.location=`${r.hash}_o${s}`}),t.code.forEach((t,e)=>t.success(`${r.hash}_o${e+1}`));for(const o of t.outputs){const s=t.stateAfter.get(o),i=util.aam(s.json,[util.aao(s.refs)]),{Jig:Jig}=n(3),a=util.aal(i,[t=>{if(util.aai(t)||t instanceof Jig){const e=this.aayc.get(t.origin)||t.location;return{$ref:e.startsWith(r.hash)?e.slice(64):e}}}]);a.origin.startsWith(r.hash)&&delete a.origin,a.location.startsWith(r.hash)&&delete a.location;let c=o.constructor[`origin${e}`];c.startsWith(r.hash)&&(c=c.slice(64));const l={type:c,state:a};await this.state.set(s.json.location,l)}t.code.forEach(t=>this.run.owner.aavb(t.sandbox)),t.outputs.forEach(e=>this.run.owner.aavb(t.aazb.get(e))),this.aajb()}async broadcast(t){try{await this.blockchain.broadcast(t)}catch(t){let e=`Broadcast failed, ${t.message}`;if(-1!==t.toString().indexOf("tx has no inputs")||-1!==t.toString().indexOf("tx fee too low")){e=`${e}\n\n${"Hint: Is the purse funded to pay for this transaction?"}`}throw new Error(e)}}async aajb(){this.aazc.shift(),this.aazc.length?this.aakb():(this.aawc.forEach(t=>t.resolve()),this.aawc=[])}async sync(t={}){const e=new Set,n=t=>e.add(t.hash);this.aaxc.add(n);const r=async()=>t.target&&(void 0===t.forward||t.forward)?this.aaib(t.target,e).then(()=>t.target):t.target;if(!this.aazc.length)return r();const o=new Promise((t,e)=>{this.aawc.push({resolve:t,reject:e})}),s=()=>this.aaxc.delete(n);return o.then(()=>(s(),r())).catch(t=>(s(),(t=>r().then(()=>{throw t}).catch(e=>{throw t}))(t)))}async aaib(t,e=new Set,o=new Map){const s=o.get(t.origin);if(s)return this.code.aacd.aaac=!1,Object.assign(t,s),this.code.aacd.aaac=!0,t;let i=t.location.slice(0,64),a=parseInt(t.location.slice(66)),c=await this.blockchain.fetch(i,!e.has(i));for(e.add(i);;){const n=c.outputs[a];if(void 0===n.spentTxId){throw new Error(`${"Blockchain API does not support forward syncing."}\n\n${"To just publish pending transactions, use `jig.sync({ forward: false })`."}`)}if(null===n.spentTxId)break;c=await this.blockchain.fetch(n.spentTxId,!e.has(i));const o=new r;if(await o.import(c,this.run,t,!0),e.add(n.spentTxId),!Array.from(o.aazb.values()).some(e=>e===t))throw new Error("jig not found");i=t.location.slice(0,64),a=parseInt(t.location.slice(66))}o.set(t.origin,t);const l=new Set,{Jig:Jig}=n(3);this.code.aacd.aaac=!1,util.aap(t,(t,e,n)=>{t&&t instanceof Jig&&n&&l.add(t)}),this.code.aacd.aaac=!0;for(const t of l)await this.aaib(t,e,o)}}},function(t,e,n){const r=n(1),util=n(2),{Blockchain:o}=n(9);function s(t){switch(typeof t){case"number":if(!Number.isInteger(t))throw new Error(`Option splits must be an integer: ${t}`);if(t<=0)throw new Error(`Option splits must be at least 1: ${t}`);return t;case"undefined":return 10;default:throw new Error(`Invalid splits option: ${t}`)}}function i(t){switch(typeof t){case"number":if(!Number.isFinite(t))throw new Error(`Option feePerKb must be finite: ${t}`);if(t<=0)throw new Error(`Option feePerKb must be at least 1: ${t}`);return t;case"undefined":return 1e3;default:throw new Error(`Invalid feePerKb option: ${t}`)}}t.exports={Pay:class{async pay(t){throw new Error("Not implemented")}},Purse:class{constructor(t={}){this.logger=function(t){switch(typeof t){case"object":return t;case"undefined":return null;default:throw new Error(`Invalid logger option: ${t}`)}}(t.logger),this.blockchain=function(t){switch(typeof t){case"object":if(!o.aahc(t))throw new Error("Invalid blockchain option");return t;case"undefined":throw new Error("Option blockchain is required");default:throw new Error(`Invalid blockchain option: ${t}`)}}(t.blockchain),this._splits=s(t.splits),this._feePerKb=i(t.feePerKb);const e=util.bsvNetwork(this.blockchain.network);this.bsvPrivateKey=new r.PrivateKey(t.privkey,e),this.privkey=this.bsvPrivateKey.toString(),this.bsvAddress=this.bsvPrivateKey.toAddress(),this.address=this.bsvAddress.toString()}get splits(){return this._splits}set splits(t){this._splits=s(t)}get feePerKb(){return this._feePerKb}set feePerKb(t){this._feePerKb=i(t)}async pay(t){let e=await this.blockchain.utxos(this.address);if(!e.length){const t=`Hint: Have you funded the purse address ${this.address}?`;this.logger&&this.logger.warn(`No purse utxos\n\n${t}`)}e=function(t){for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t}(e);let n=Math.max(1e3,t._estimateFee()+t._getOutputAmount()),r=0,o=t._getInputAmount(),s=0,i=0;t.feePerKb(this.feePerKb);for(const a of e){t.from(a),r+=a.satoshis,o+=a.satoshis,s+=1,n+=150;const c=this.splits-e.length+s-i;for(let t=0;t<c;t++)n+=40,n+=546,i+=1;if(o>n+50)break}if(o<=n+50)throw new Error("Not enough funds");const a=n-546*i,c=Math.floor((r-a)/i);for(let e=0;e<i;e++)e===i-1?t.change(this.bsvAddress):t.to(this.bsvAddress,c);return t.sign(this.bsvPrivateKey),t}async balance(){return(await this.utxos()).reduce((t,e)=>t+e.satoshis,0)}async utxos(){const t=await this.blockchain.utxos(this.address),e=await Promise.all(t.map(t=>this.blockchain.fetch(t.txid)));return t.filter((t,n)=>"other"===util.aag(e[n],t.vout))}}}},function(t,e,n){t.exports=n(27)},function(t,e,n){"use strict";var r=n(0),o=n(10),s=n(29),i=n(16);function a(t){var e=new s(t),n=o(s.prototype.request,e);return r.extend(n,s.prototype,e),r.extend(n,e),n}var c=a(n(13));c.Axios=s,c.create=function(t){return a(i(c.defaults,t))},c.Cancel=n(17),c.CancelToken=n(42),c.isCancel=n(12),c.all=function(t){return Promise.all(t)},c.spread=n(43),t.exports=c,t.exports.default=c},function(t,e){t.exports=function(t){return null!=t&&null!=t.constructor&&"function"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}},function(t,e,n){"use strict";var r=n(0),o=n(11),s=n(30),i=n(31),a=n(16);function c(t){this.defaults=t,this.interceptors={request:new s,response:new s}}c.prototype.request=function(t){"string"==typeof t?(t=arguments[1]||{}).url=arguments[0]:t=t||{},(t=a(this.defaults,t)).method=t.method?t.method.toLowerCase():"get";var e=[i,void 0],n=Promise.resolve(t);for(this.interceptors.request.forEach((function(t){e.unshift(t.fulfilled,t.rejected)})),this.interceptors.response.forEach((function(t){e.push(t.fulfilled,t.rejected)}));e.length;)n=n.then(e.shift(),e.shift());return n},c.prototype.getUri=function(t){return t=a(this.defaults,t),o(t.url,t.params,t.paramsSerializer).replace(/^\?/,"")},r.forEach(["delete","get","head","options"],(function(t){c.prototype[t]=function(e,n){return this.request(r.merge(n||{},{method:t,url:e}))}})),r.forEach(["post","put","patch"],(function(t){c.prototype[t]=function(e,n,o){return this.request(r.merge(o||{},{method:t,url:e,data:n}))}})),t.exports=c},function(t,e,n){"use strict";var r=n(0);function o(){this.handlers=[]}o.prototype.use=function(t,e){return this.handlers.push({fulfilled:t,rejected:e}),this.handlers.length-1},o.prototype.eject=function(t){this.handlers[t]&&(this.handlers[t]=null)},o.prototype.forEach=function(t){r.forEach(this.handlers,(function(e){null!==e&&t(e)}))},t.exports=o},function(t,e,n){"use strict";var r=n(0),o=n(32),s=n(12),i=n(13),a=n(40),c=n(41);function l(t){t.cancelToken&&t.cancelToken.throwIfRequested()}t.exports=function(t){return l(t),t.baseURL&&!a(t.url)&&(t.url=c(t.baseURL,t.url)),t.headers=t.headers||{},t.data=o(t.data,t.headers,t.transformRequest),t.headers=r.merge(t.headers.common||{},t.headers[t.method]||{},t.headers||{}),r.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete t.headers[e]})),(t.adapter||i.adapter)(t).then((function(e){return l(t),e.data=o(e.data,e.headers,t.transformResponse),e}),(function(e){return s(e)||(l(t),e&&e.response&&(e.response.data=o(e.response.data,e.response.headers,t.transformResponse))),Promise.reject(e)}))}},function(t,e,n){"use strict";var r=n(0);t.exports=function(t,e,n){return r.forEach(n,(function(n){t=n(t,e)})),t}},function(t,e){var n,r,o=t.exports={};function s(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function a(t){if(n===setTimeout)return setTimeout(t,0);if((n===s||!n)&&setTimeout)return n=setTimeout,setTimeout(t,0);try{return n(t,0)}catch(e){try{return n.call(null,t,0)}catch(e){return n.call(this,t,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:s}catch(t){n=s}try{r="function"==typeof clearTimeout?clearTimeout:i}catch(t){r=i}}();var c,l=[],u=!1,h=-1;function p(){u&&c&&(u=!1,c.length?l=c.concat(l):h=-1,l.length&&f())}function f(){if(!u){var t=a(p);u=!0;for(var e=l.length;e;){for(c=l,l=[];++h<e;)c&&c[h].run();h=-1,e=l.length}c=null,u=!1,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===i||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t)}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(t)}}function d(t,e){this.fun=t,this.array=e}function g(){}o.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];l.push(new d(t,e)),1!==l.length||u||a(f)},d.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=g,o.addListener=g,o.once=g,o.off=g,o.removeListener=g,o.removeAllListeners=g,o.emit=g,o.prependListener=g,o.prependOnceListener=g,o.listeners=function(t){return[]},o.binding=function(t){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(t){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},function(t,e,n){"use strict";var r=n(0);t.exports=function(t,e){r.forEach(t,(function(n,r){r!==e&&r.toUpperCase()===e.toUpperCase()&&(t[e]=n,delete t[r])}))}},function(t,e,n){"use strict";var r=n(15);t.exports=function(t,e,n){var o=n.config.validateStatus;!o||o(n.status)?t(n):e(r("Request failed with status code "+n.status,n.config,null,n.request,n))}},function(t,e,n){"use strict";t.exports=function(t,e,n,r,o){return t.config=e,n&&(t.code=n),t.request=r,t.response=o,t.isAxiosError=!0,t.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,aabc:this.aabc,config:this.config,code:this.code}},t}},function(t,e,n){"use strict";var r=n(0),o=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];t.exports=function(t){var e,n,s,i={};return t?(r.forEach(t.split("\n"),(function(t){if(s=t.indexOf(":"),e=r.trim(t.substr(0,s)).toLowerCase(),n=r.trim(t.substr(s+1)),e){if(i[e]&&o.indexOf(e)>=0)return;i[e]="set-cookie"===e?(i[e]?i[e]:[]).concat([n]):i[e]?i[e]+", "+n:n}})),i):i}},function(t,e,n){"use strict";var r=n(0);t.exports=r.isStandardBrowserEnv()?function(){var t,e=/(msie|trident)/i.test(navigator.userAgent),n=document.createElement("a");function o(t){var r=t;return e&&(n.setAttribute("href",r),r=n.href),n.setAttribute("href",r),{href:n.href,protocol:n.protocol?n.protocol.replace(/:$/,""):"",host:n.host,search:n.search?n.search.replace(/^\?/,""):"",hash:n.hash?n.hash.replace(/^#/,""):"",hostname:n.hostname,port:n.port,pathname:"/"===n.pathname.charAt(0)?n.pathname:"/"+n.pathname}}return t=o(window.location.href),function(e){var n=r.isString(e)?o(e):e;return n.protocol===t.protocol&&n.host===t.host}}():function(){return!0}},function(t,e,n){"use strict";var r=n(0);t.exports=r.isStandardBrowserEnv()?{write:function(t,e,n,o,s,i){var a=[];a.push(t+"="+encodeURIComponent(e)),r.isNumber(n)&&a.push("expires="+new Date(n).toGMTString()),r.isString(o)&&a.push("path="+o),r.isString(s)&&a.push("domain="+s),!0===i&&a.push("secure"),document.cookie=a.join("; ")},read:function(t){var e=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove:function(t){this.write(t,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(t,e,n){"use strict";t.exports=function(t){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t)}},function(t,e,n){"use strict";t.exports=function(t,e){return e?t.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):t}},function(t,e,n){"use strict";var r=n(17);function o(t){if("function"!=typeof t)throw new TypeError("executor must be a function.");var e;this.promise=new Promise((function(t){e=t}));var n=this;t((function(t){n.reason||(n.reason=new r(t),e(n.reason))}))}o.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},o.source=function(){var t;return{token:new o((function(e){t=e})),cancel:t}},t.exports=o},function(t,e,n){"use strict";t.exports=function(t){return function(e){return t.apply(null,e)}}},function(t,e,n){const r=n(1),util=n(2);t.exports=class{constructor(t,e){const n=util.bsvNetwork(e.network);this.logger=e.logger,this.run=e.run,t=t||new r.PrivateKey(n);try{const e=new r.PrivateKey(t,n);if(e.toString()!==t.toString())throw new Error;return this.aaqb(e)}catch(t){if("Private key network mismatch"===t.message)throw t}try{return this.aarb(new r.PublicKey(t,{network:n}))}catch(t){}try{return this.aasb(new r.Address(t,n))}catch(t){if("Address has mismatched network type."===t.message)throw t}throw new Error(`bad owner key or address: ${t}`)}aaqb(t){return this.bsvPrivateKey=t,this.privkey=t.toString(),this.aarb(t.publicKey)}aarb(t){return this.bsvPublicKey=t,this.pubkey=t.toString(),this.aasb(t.toAddress())}aasb(t){return this.bsvAddress=t,this.address=t.toString(),this.refs=new Map,this}get jigs(){try{return Array.from(this.refs.values()).filter(t=>t instanceof this.run.constructor.Jig)}catch(t){return this.logger&&this.logger.error(`Bad token found in owner refs. Removing.\n\n${t}`),this.aaub(),this.jigs}}get code(){try{return Array.from(this.refs.values()).filter(t=>!(t instanceof this.run.constructor.Jig))}catch(t){return this.logger&&this.logger.error(`Bad token found in owner refs. Removing.\n\n${t}`),this.aaub(),this.code}}aaub(){let t=!0;const e=[];for(const[n,r]of this.refs)try{const e=r instanceof this.run.constructor.Jig;t=t?!e:e}catch(t){e.push(n)}e.forEach(t=>this.refs.delete(t))}async sign(t){return this.bsvPrivateKey&&t.sign(this.bsvPrivateKey),t}async sync(){return await this.run.aasc.sync(),this._query||(this._query=new Promise((t,e)=>{this.aatb().then(()=>{this._query=null,t()}).catch(t=>{this._query=null,e(t)})})),this._query}async aatb(){const t=await this.run.blockchain.utxos(this.address),e=new Map,n=new Map;for(const[t,r]of this.refs){"string"!=typeof t&&e.set(t,r);try{n.set(r.location,r)}catch(t){}}for(const r of t){const t=`${r.txid}_o${r.vout}`,o=n.get(t);if(o)e.delete(o),e.set(t,o);else try{const n=await this.run.load(t);e.set(n.origin,n)}catch(e){this.logger&&this.logger.error(`Failed to load owner location ${t}\n\n${e.toString()}`)}}this.refs=e}aavb(t){this.refs.delete(t);try{if(t.owner===this.pubkey)try{if(void 0===t.origin)throw new Error;if(t.origin.startsWith("_"))throw new Error;this.refs.set(t.origin,t)}catch(e){this.refs.set(t,t)}else try{this.refs.delete(t.origin)}catch(t){}}catch(t){}}}},function(t,e,n){const{Address:r,Transaction:o}=n(1);t.exports=class t{constructor(e={}){if(e.lastBlockchain&&e.lastBlockchain instanceof t)return e.lastBlockchain;this.network="mock",this.aanc=new Map,this.aaoc=new Map,this.aapc=new Map,this.mempool=new Set,this.mempoolChainLimit=25,this.aaqc=-1}async broadcast(t){if(0===t.inputs.length)throw new Error("tx has no inputs");if(0===t.outputs.length)throw new Error("tx has no outputs");if(t.getFee()<t.toBuffer().length)throw new Error("tx fee too low");if(!0!==t.verify())throw new Error(t.verify());if(!0!==t.isFullySigned())throw new Error("tx not fully signed");const e=new Set;if(t.inputs.forEach((t,n)=>{const r=`${t.prevTxId.toString("hex")}_o${t.outputIndex}`;if(!this.aaoc.has(r))throw new Error(`tx input ${n} missing or spent`);if(e.has(r))throw new Error(`already spent input ${n}`);e.add(r)}),t.unconfirmedHeight=Math.max(...t.inputs.map(t=>this.aanc.get(t.prevTxId.toString("hex")).unconfirmedHeight+1)),t.unconfirmedHeight>this.mempoolChainLimit){throw new Error(`too-long-mempool-chain\n\n${"Hint: Use run.blockchain.block() to produce blocks on the mockchain."}`)}t.inputs.forEach((t,e)=>{const n=t.prevTxId.toString("hex"),r=`${n}_o${t.outputIndex}`,o=this.aanc.get(n).outputs[t.outputIndex].script.toAddress("testnet").toString();this.aaoc.delete(r),this.aapc.get(o).delete(r)}),t.time=t.time||Date.now(),t.aaqc=-1,t.confirmations=0,this.aanc.set(t.hash,t),this.mempool.add(t),t.outputs.forEach(t=>{t.spentTxId=null,t.spentIndex=null,t.spentHeight=null}),t.inputs.forEach((e,n)=>{const r=this.aanc.get(e.prevTxId.toString("hex")).outputs[e.outputIndex];r.spentTxId=t.hash,r.spentIndex=n,r.spentHeight=-1}),t.outputs.forEach((e,n)=>{const r={txid:t.hash,vout:n,script:e.script,satoshis:e.satoshis},o=`${t.hash}_o${n}`;this.aaoc.set(o,r);const s=e.script.toAddress("testnet").toString(),i=this.aapc.get(s)||new Set;i.add(o),this.aapc.set(s,i)})}async fetch(t,e=!1){const n=this.aanc.get(t);if(!n)throw new Error(`tx not found: ${t}`);return n}async utxos(t){const e=new r(t,"testnet").toString(),n=this.aapc.get(e);return n?Array.from(n).map(t=>this.aaoc.get(t)):[]}fund(t,e){const n=Math.random().toString(),s=(new o).addData(n).to(new r(t,"testnet"),e);s.time=Date.now(),s.confirmations=0,s.aaqc=-1,s.unconfirmedHeight=0,this.aanc.set(s.hash,s);const i=s.outputs[1],a={txid:s.hash,vout:1,script:i.script,satoshis:i.satoshis},c=`${s.hash}_o1`;this.aaoc.set(c,a);const l=this.aapc.get(t.toString())||new Set;l.add(c),this.aapc.set(t.toString(),l)}block(){this.aaqc+=1;for(const t of this.mempool){t.aaqc=this.aaqc,t.unconfirmedHeight=0;for(const e of t.inputs){this.aanc.get(e.prevTxId.toString("hex")).outputs[e.outputIndex].spentHeight=this.aaqc}}this.mempool=new Set}}},function(t,e){class n{constructor(t={}){this.cache=new Map,this.aaad=0;const e=void 0===t.maxSizeMB?10:t.maxSizeMB;this.aabd=Math.floor(1e3*e*1e3)}async get(t){const e=this.cache.get(t);if(e)return this.set(t,e),e}async set(t,e){const r=this.cache.get(t);if(r){if(!function t(e,n){if(typeof e!=typeof n)return!1;if("object"!=typeof e||!e||!n)return e===n;const r=Array.from(Object.keys(e)),o=Array.from(Object.keys(n));return r.length===o.length&&!r.some(r=>!t(e[r],n[r]))}(e,r)){throw new Error(`Attempt to set different states for the same location: ${t}\n\n${"This is an internal Run bug. Please report it to the library developers."}`)}this.cache.delete(t)}if(this.cache.set(t,e),!r)for(this.aaad+=n.aawb(e);this.aaad>this.aabd;){const t=this.cache.keys().next().value,e=this.cache.get(t);this.cache.delete(t),this.aaad-=n.aawb(e)}}static aawb(t){switch(typeof t){case"boolean":return 5;case"number":return 9;case"string":return 2*t.length+1;case"object":{if(!t)return 5;const e=Object.keys(t);let r=1+4*e.length;return e.forEach(e=>{r+=n.aawb(e),r+=n.aawb(t[e])}),r}default:return 5}}}t.exports={State:class{async get(t){throw new Error("not implemented")}async set(t,e){throw new Error("not implemented")}},StateCache:n}},function(t,e,n){const Jig=n(5),expect=n(18);class Token extends Jig{init(t,e,n){if(expect(this.constructor).not.toBe(Token,"Token must be extended"),void 0!==e)return expect(e).toBeObject("bad token type"),expect(e.constructor).toBe(this.constructor,"bad token class"),this._checkAmount(t),e._decreaseAmount(t),void(this.amount=t);if(void 0!==n){if(expect(n).toBeArray(),expect(n.length).toBeGreaterThanOrEqualTo(2,"must combine at least two tokens"),n.some(t=>t.constructor!==this.constructor))throw new Error("cannot combine different token classes");const t=t=>n.reduce((e,n)=>n===t?e+1:e,0);if(n.some(e=>t(e)>1))throw new Error("cannot combine duplicate tokens");return this.amount=0,n.forEach(t=>{this.amount+=t.amount,t._destroy()}),void this._checkAmount(this.amount)}this._checkAmount(t),expect(this.owner).toBe(this.constructor.owner,`Only ${this.constructor.name}'s owner may mint`),this.amount=t,this._onMint(t,caller)}send(t,e){if(e=void 0===e?this.amount:e,this._checkAmount(e),expect(e).toBeLessThanOrEqualTo(this.amount,"not enough funds"),this.amount===e)return this.owner=t,null;const n=new this.constructor(this.amount-e,this);return this.owner=t,n}get value(){let t=this.amount;for(let e=0;e<this.constructor.decimals;e++)t/=10;return t}static combine(...t){return new this(void 0,void 0,t)}_destroy(){this.amount=0,this.owner="029d11c250cc84a6ffbaf84fc28da82fc4deee214021bed2dcaa22d5193d22e273"}_decreaseAmount(t){this.amount-=t}_checkAmount(t){expect(t).toBeNumber("amount is not a number"),expect(t).toBeInteger("amount must be an integer"),expect(t).toBeGreaterThan(0,"amount must be positive"),expect(t).toBeLessThanOrEqualTo(Number.MAX_SAFE_INTEGER,"amount too large")}_onMint(t,e){}}Token.decimals=0,Token.deps={expect:expect},Token.originTestnet="745a40d575543d7f6edfcf9fb2bbab8afe73626effad7d58bd39096bc257e1a4_o1",Token.locationTestnet="745a40d575543d7f6edfcf9fb2bbab8afe73626effad7d58bd39096bc257e1a4_o1",Token.ownerTestnet="02749f92ba405487340ebba1cfa54925e64fcb5728cbd384f0a5dda43f9c2a73eb",Token.originMainnet="d92d2608c297fb7455c7f33d99a1cc7b48f91ffcb5b62595e249cf1e33fbbf43_o1",Token.locationMainnet="d92d2608c297fb7455c7f33d99a1cc7b48f91ffcb5b62595e249cf1e33fbbf43_o1",Token.ownerMainnet="031821479809d3b0b6271ada846e6b9ead2f350b9373a39e4f61db4a721f8aa855",t.exports=Token}]);